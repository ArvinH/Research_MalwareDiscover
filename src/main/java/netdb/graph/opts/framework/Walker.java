package netdb.graph.opts.framework;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.TreeMap;

import com.tinkerpop.blueprints.Edge;
import com.tinkerpop.blueprints.Vertex;
/**
 * 
 * @author arvin
 * Walker : record all nodes and edges it walks by.
 */
public class Walker {
  private ArrayList<Vertex> visitedNodes;
  private TreeMap<Integer, ArrayList<Vertex>> foundPathvertex;
  private TreeMap<Integer, ArrayList<Edge>> foundPathedge;
  private ArrayList<Edge> visitedEdges;
  private int nth_path_node;
  private int nth_path_edge;
  private ArrayList<Vertex> targetList;
  private SimpleDateFormat simpleDateFormat;
  private String queryTime;
  private String queryTerm;
  private HashMap<Vertex,Integer> meetedTarget;
  private File file;
  public Walker() {
	  this.visitedNodes = new ArrayList<Vertex>();
	  this.visitedEdges = new ArrayList<Edge>();
	  this.foundPathvertex = new TreeMap<Integer, ArrayList<Vertex>>();
	  this.foundPathedge = new TreeMap<Integer, ArrayList<Edge>>();
	  this.nth_path_node = 0;
	  this.nth_path_edge = 0;
	  this.simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
	  this.targetList = new ArrayList<Vertex>();
	  this.queryTime = null;
	  this.meetedTarget = new HashMap<Vertex, Integer>();
	  this.file = new File("C:\\Users\\netdb\\Desktop\\eachQueryTargetCount.csv");
	// if file doesnt exists, then create it
		if (!file.exists()) {
			try {
				file.createNewFile();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
  }
  
  public void setQueryTerm(String queryTerm){
	  this.queryTerm = queryTerm;
  }
  public String getQueryTerm(){
	  return this.queryTerm;
  }
  
  public void setQueryTime(String queryTime){
	  this.queryTime = queryTime;
  }
  public String getQueryTime(){
	  return this.queryTime;
  }
  
  public void printEachQueryTargetCount(){
		 try{
			  
				FileWriter fw = new FileWriter(file.getName(),true);
				BufferedWriter bw = new BufferedWriter(fw);
				if(this.meetedTarget.keySet().size() > 0){
					bw.write(this.queryTerm+"\n");
					bw.write("-----------"+"\n");
					  for(Vertex v : this.meetedTarget.keySet()){
						  bw.write(v.getProperty("nodeID")+","+meetedTarget.get(v)+"\n");
					  }
					  bw.write("-----------"+"\n");
					bw.close();
				}
				
		  }
		  catch(IOException e){
			  e.printStackTrace();
		  }
			
	  
  }
  
  public boolean containTargetOrNot(Vertex v){
	  if("1".equals(v.getProperty("type"))){
		  if(meetedTarget.containsKey(v)){
			  int count = meetedTarget.get(v);
			  meetedTarget.put(v, count+1);
		  }
		  else{
			  meetedTarget.put(v, 1);
		  }
	  }
	  return (this.targetList.contains(v))? true : false;
  }
  
  public void addNode(Vertex v, boolean foundTargetOrNot) {
	  if(foundTargetOrNot){
			//record new path
			  this.visitedNodes.add(v);
			  this.targetList.add(v);
			  this.foundPathvertex.put(this.nth_path_node, this.visitedNodes);
			  this.nth_path_node = this.nth_path_node + 1;
			  this.visitedNodes = new ArrayList<Vertex>();  
	  }
	  else if(!foundTargetOrNot){
		  this.visitedNodes.add(v);
		  this.foundPathvertex.put(this.nth_path_node, this.visitedNodes);
	  }
  }
  
  public void addEdge(Edge e,Vertex v, boolean foundTargetOrNot) {
	  if(foundTargetOrNot){
			//record new path
			  this.visitedEdges.add(e);
			  this.foundPathedge.put(this.nth_path_edge, this.visitedEdges);
			  this.nth_path_edge = this.nth_path_edge + 1;
			  this.visitedEdges = new ArrayList<Edge>();
	  }
	  else if(!foundTargetOrNot){
		  this.visitedEdges.add(e);
		  this.foundPathedge.put(this.nth_path_edge, this.visitedEdges);
	  }
	  
  }
  
  public void cleanEdgeWalkedLable(){
	  Iterator<Edge> edgePtr = this.foundPathedge.get(this.nth_path_edge-1).iterator();
	  Edge edge = null;
	  while(edgePtr.hasNext()){
		  edge = edgePtr.next();
		  edge.setProperty("walked", "0");
	  }
  }
  
  public Vertex getLeastNode(boolean foundTargetOrNot) {
	  if(foundTargetOrNot){
		  return this.foundPathvertex.get(this.nth_path_node-1).get(this.foundPathvertex.get(this.nth_path_node-1).size()-1);
	  }
	  return this.visitedNodes.get(this.visitedNodes.size()-1);
  }
  
  public Vertex getRoot(boolean foundTargetOrNot){
	  if(foundTargetOrNot){
		 return this.foundPathvertex.get(this.nth_path_node-1).get(0);
	  }
	  else{
		 return this.visitedNodes.get(0);
	  }
  }
  
  public ArrayList<Vertex> getFoundTargets(){
	  Vertex targetCandidate = null;
	  targetList.clear();
	  for(int i : this.foundPathvertex.keySet()){
		  targetCandidate = this.foundPathvertex.get(i).get(this.foundPathvertex.get(i).size()-1);
		  if("1".equals(targetCandidate.getProperty("type"))){
			  this.printPath(i);
			  System.out.println("path length = "+ (this.foundPathvertex.get(i).size()-1));
			  this.setBorderProbEdge(i,targetCandidate);
			  targetList.add(targetCandidate);
		  }
	  }
	  return targetList;
  }
  
  public void setBorderProbEdge(int i, Vertex targetV){
	  ArrayList<Vertex> vertexList = this.foundPathvertex.get(i);
	  Vertex tempV;
	  String timeStamp = null;
	 for(int index = vertexList.size()-1; index >= 0; index--){
		  tempV = vertexList.get(index);
		  if("yes".equals((String)tempV.getProperty("border")) && "0".equals((String)tempV.getProperty("valid"))){
			  tempV.addEdge("attachedTarget", targetV);
			  timeStamp = this.simpleDateFormat.format(this.getQueryTime());
			  tempV.setProperty("valid", "1");
			  tempV.setProperty("validTime", timeStamp);
			  break;
		  }
		  
	  }
	  
  }
  
  public void setNewPath(){
	  this.nth_path_node = this.nth_path_node + 1;
	  this.visitedNodes = new ArrayList<Vertex>();
	  this.nth_path_edge = this.nth_path_edge + 1;
	  this.visitedEdges = new ArrayList<Edge>();
  }

  
  public TreeMap<Integer, ArrayList<Edge>> getAllPath(){
	  //return ALL Path
	  return this.foundPathedge;
  }
  
  public ArrayList<Edge> getLastPath(){
	  //return last Path(all edge in the path)
	 return this.foundPathedge.get(this.foundPathedge.lastKey());
  }
  public ArrayList<Edge> getPath(int i){
	  //return ith Path(all edge in the path)
	 return this.foundPathedge.get(i);
  }

  public double getPathWeight() {
	  //not finished yet
	  double weight = 0;
	  Iterator<Edge> eptr = this.visitedEdges.iterator();
	  while(eptr.hasNext()){
		  weight += (double)eptr.next().getProperty("weight");
	  }
	  return weight;
  }
  
  private void printPath(int i){
		  for(int j = 0; j < this.foundPathvertex.get(i).size(); j++){
			  System.out.print(this.foundPathvertex.get(i).get(j).getProperty("nodeID"));
			  System.out.print(" ("+ this.foundPathvertex.get(i).get(j).getProperty("subgraphID")+")");
			  if(j != this.foundPathvertex.get(i).size()-1){
				  System.out.print(" -> ");		
			  }
		  }
		  System.out.println();
  }
  
  
}
