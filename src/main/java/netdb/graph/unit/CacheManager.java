package netdb.graph.unit;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.TreeMap;

import netdb.database.opt.DatabaseOpts;
import netdb.graph.opts.framework.GBlock;
import netdb.graph.opts.framework.OptsExperimentSet;

import com.tinkerpop.blueprints.Vertex;
import com.tinkerpop.blueprints.impls.neo4j.Neo4jGraph;

public class CacheManager {
    public static int BLOCK_CACHE_SIZE = 15;
	private TreeMap<String, GBlock> map = null;
	private HashMap<String,Boolean> GraphPartSet = null;
  
  public CacheManager() {
	  map = new TreeMap<String, GBlock>();
	  GraphPartSet = new HashMap<String,Boolean>();
	  String[] GraphPartIDList = OptsExperimentSet.GRAPH_PARTID;
	  //initial false value to all id in Set
	  for(String id : GraphPartIDList){
		  GraphPartSet.put(id,false);
	  }
	  
  }
  
  
  public Vertex findVertexInCache(String vertexID){
	  /*
	  Iterator<Entry<String, GBlock>> cacheItr = map.entrySet().iterator();
	  Vertex root = null;
	  Iterator<Vertex> matchedNode;
	  //need to change to compare property nodeID
	  //or find the way to combine nodeID and original neo4j id
	  while(cacheItr.hasNext()){
		  Neo4jGraph tempGraph = cacheItr.next().getValue().getGraph();
		  matchedNode = tempGraph.getVertices("nodeID", vertexID).iterator();
		  while(matchedNode.hasNext()){
			  root = matchedNode.next();
		  }
		  if(root != null){
			  return root;
		  }  
	  }
	  //if vertexName is not in Cache...
	  //check the cache date and use LRU to replace the GBlock
	  this.updateCache();

	  return findVertexInCache(vertexID);
	  */
	  DatabaseOpts databaseOpts = new DatabaseOpts("localhost:3306","graphPartition","root","155013");
	  String subgraphID = databaseOpts.getPartID(vertexID);
	  if(!this.inCacheOrNot(subgraphID)){
		  this.loadGraphToCache(subgraphID);
		}
	  
	  return findVertexInOtherGraph(vertexID, subgraphID); 
  }
  
  
  public Vertex findVertexInOtherGraph(String nodeID, String subgraphID) {
		GBlock graphNeedloaded = (GBlock) this.getCache(subgraphID);
		Iterator<Vertex> tempVertex = graphNeedloaded.getGraph().getVertices("nodeID", nodeID).iterator();
		Vertex returnVertex = null;
		while(tempVertex.hasNext()){
			returnVertex = tempVertex.next();
		}
		return returnVertex;
	}
  
  
  public void updateCache(){
	  Iterator<Entry<String, GBlock>> cacheItr = map.entrySet().iterator();
	  Entry<String, GBlock> tempEntry;
	  ArrayList<String> shouldBeremoveList = new ArrayList<String>();
	  int numOfupdate = 0; //control update block numbers
	  while(cacheItr.hasNext()){
		  // check which block should be replace and which block should be put in
		  tempEntry = cacheItr.next();
		  if(tempEntry.getValue().isExpired()){
			  numOfupdate = numOfupdate + 1;
			  //remove and shutdown the expired GBlock
			  shouldBeremoveList.add(tempEntry.getKey());
			 
			  //And set its partID to false in GraphPartSet
			  GraphPartSet.put(tempEntry.getKey(), false);
		  }
	  }
	  for(String key : shouldBeremoveList){
		  map.get(key).shutdownGB();
		  map.remove(key); 
	  }
	  
	  
	  //which gblock should be update into cache?
	  
	  for(String PartID : GraphPartSet.keySet()){
		  if(!GraphPartSet.get(PartID) && (numOfupdate > 0)){
			  loadGraphToCache(PartID);
			  GraphPartSet.put(PartID, true);
			  numOfupdate = numOfupdate - 1;
		  }
	  }
	  
	  
  }
  public void loadGraphToCache(String BorderID){
	  String prefix = "/Volumes/MacintoshHDD/Users/arvin/Documents/neo4j-community-1.9.5/data/";
	  HashMap<String, String> config = new HashMap<String, String>();
	  config.put("online_backup_enabled", "false");
	  //System.out.print(BorderID+" prepared to be inserted  ");
	  Neo4jGraph indexedGraph = new Neo4jGraph(prefix+"graph-"+BorderID+".db", config);
	  GBlock gBlock = new GBlock(indexedGraph,BorderID);
	  //System.out.println(BorderID+" db inserted!");
	  this.putCache(BorderID, gBlock);
	  GraphPartSet.put(BorderID, true);
	  
  }
  public void putCache(String id, Cacheable object)
  {
	  if (map.containsKey(id)) {
	    /*just update*/
	  }
	  else {
		  if (map.size() > BLOCK_CACHE_SIZE) {
			  updateCache();
		  }
		  map.put(id, (GBlock)object);  
	  }
    
    
  }
  
  public void cleanCache() {
	  for(String index : map.keySet()){
		  map.get(index).shutdownGB();
	  }
	  map.clear();
  }
  
  public Cacheable getCache(String id)
  {
      Cacheable object = (Cacheable)map.get(id);
      if (object == null){
    	  return null;
      }
      else{
    	  return object;
      }
      /*
      if (object.isExpired())
      {
        map.remove(id);
        return null;
      }
      else
      {
        return object;
      }
      */
  }  
  
  public boolean inCacheOrNot(String subgraphID){
	  if(GraphPartSet.get(subgraphID)){
		  return true;
	  }
	  else{
		  return false;
	  }
  }

}
