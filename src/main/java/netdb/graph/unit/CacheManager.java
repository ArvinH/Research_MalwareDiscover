package netdb.graph.unit;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.TreeMap;

import org.neo4j.graphdb.Node;
import org.neo4j.graphdb.index.AutoIndexer;

import netdb.database.opt.DatabaseOpts;
import netdb.graph.opts.framework.GBlock;
import netdb.graph.opts.framework.OptsExperimentSet;

import com.tinkerpop.blueprints.CloseableIterable;
import com.tinkerpop.blueprints.Element;
import com.tinkerpop.blueprints.Index;
import com.tinkerpop.blueprints.Vertex;
import com.tinkerpop.blueprints.impls.neo4j.Neo4jGraph;

public class CacheManager {
	public static int BLOCK_CACHE_SIZE = 10;
	private TreeMap<String, GBlock> map = null;
	private HashMap<String, Boolean> GraphPartSet = null;

	public CacheManager() {
		map = new TreeMap<String, GBlock>();
		GraphPartSet = new HashMap<String, Boolean>();
		String[] GraphPartIDList = OptsExperimentSet.GRAPH_PARTID;
		// initial false value to all id in Set
		for (String id : GraphPartIDList) {
			System.out.println(id);
			GraphPartSet.put(id, false);
		}

	}

	public Vertex findVertexInCache(String vertexID) {
		/*
		 * Iterator<Entry<String, GBlock>> cacheItr = map.entrySet().iterator();
		 * Vertex root = null; Iterator<Vertex> matchedNode; //need to change to
		 * compare property nodeID //or find the way to combine nodeID and
		 * original neo4j id while(cacheItr.hasNext()){ Neo4jGraph tempGraph =
		 * cacheItr.next().getValue().getGraph(); matchedNode =
		 * tempGraph.getVertices("nodeID", vertexID).iterator();
		 * while(matchedNode.hasNext()){ root = matchedNode.next(); } if(root !=
		 * null){ return root; } } //if vertexName is not in Cache... //check
		 * the cache date and use LRU to replace the GBlock this.updateCache();
		 * 
		 * return findVertexInCache(vertexID);
		 */

		DatabaseOpts databaseOpts = new DatabaseOpts("192.168.66.42:5432",
				"mrGraph4", "netdb", "netdb");
		System.out.println(vertexID + '\n');
		String subgraphID = databaseOpts.getPartID(vertexID);
		if (subgraphID == null) {
			System.out.println(vertexID + " not found");
			return null;
		}

		// String subgraphID = "single-L-forRW";
		// String subgraphID = "single-L";
		// String subgraphID = "RealSingle";
		// String subgraphID = "RealSingle-newWeight";
		// String subgraphID = "RealSingle-newWeightFunc";
		// String subgraphID = "RealSingle-SP";
		if (!this.inCacheOrNot(subgraphID)) {
			System.out.println(subgraphID);
			this.loadGraphToCache(subgraphID);
		}

		return findVertexInOtherGraph(vertexID, subgraphID);

	}

	public Vertex findVertexInOtherGraph(String nodeID, String subgraphID) {
		GBlock graphNeedloaded = (GBlock) this.getCache(subgraphID);

		Iterator<Vertex> tempVertex = graphNeedloaded.getGraph()
				.getIndex("Nodes", Vertex.class).query("nodeID", nodeID)
				.iterator();
		// Iterator<Vertex> tempVertex =
		// graphNeedloaded.getGraph().getVertices("nodeID", nodeID).iterator();
		Vertex returnVertex = null;
		while (tempVertex.hasNext()) {
			returnVertex = tempVertex.next();
		}
		if (returnVertex == null) {
			System.out.println(nodeID + " not found");
		}
		return returnVertex;
	}

	public void updateCache() {
		Iterator<Entry<String, GBlock>> cacheItr = map.entrySet().iterator();
		Entry<String, GBlock> tempEntry;
		ArrayList<String> shouldBeremoveList = new ArrayList<String>();
		int numOfupdate = 0; // control update block numbers
		while (cacheItr.hasNext()) {
			// check which block should be replace and which block should be put
			// in
			tempEntry = cacheItr.next();
			if (tempEntry.getValue().isExpired()) {
				numOfupdate = numOfupdate + 1;
				// remove and shutdown the expired GBlock
				shouldBeremoveList.add(tempEntry.getKey());

				// And set its partID to false in GraphPartSet
				GraphPartSet.put(tempEntry.getKey(), false);
			}
		}
		for (String key : shouldBeremoveList) {
			map.get(key).shutdownGB();
			map.remove(key);
		}

		// which gblock should be update into cache?

		for (String PartID : GraphPartSet.keySet()) {
			if (!GraphPartSet.get(PartID) && (numOfupdate > 0)) {
				loadGraphToCache(PartID);
				GraphPartSet.put(PartID, true);
				numOfupdate = numOfupdate - 1;
			}
		}

	}

	public void loadGraphToCache(String BorderID) {
		String prefix = "/home/arvin/arvin/neo4j-community-1.9.7/data/";
		// String prefix =
		// "/Volumes/MacintoshHDD/Users/arvin/Documents/neo4j-community-1.9.7/data/";
		// String prefix = "C:\\Program Files\\Neo4j Community\\";
		HashMap<String, String> config = new HashMap<String, String>();
		config.put("online_backup_enabled", "false");
		config.put("GraphDatabaseSettings.node_keys_indexable", "Nodes");
		config.put("GraphDatabaseSettings.node_auto_indexing", "true");
		/*
		 * config.put("neostore.nodestore.db.mapped_memory", "20G");
		 * config.put("neostore.relationshipstore.db.mapped_memory", "30G");
		 * config.put("neostore.propertystore.db.mapped_memory", "50G");
		 * config.put("neostore.propertystore.db.strings.mapped_memory", "20G");
		 * config.put("neostore.propertystore.db.arrays.mapped_memory", "20G");
		 */
		config.put("cache_type", "soft");
		// System.out.print(BorderID+" prepared to be inserted  ");
		Neo4jGraph indexedGraph = new Neo4jGraph(prefix + "graph-" + BorderID
				+ ".db", config);
		indexedGraph.createKeyIndex("Nodes", Vertex.class);
		GBlock gBlock = new GBlock(indexedGraph, BorderID);
		// System.out.println(BorderID+" db inserted!");
		this.putCache(BorderID, gBlock);
		GraphPartSet.put(BorderID, true);

	}

	public void putCache(String id, Cacheable object) {
		if (map.containsKey(id)) {
			/* just update */
		} else {
			/*
			 * if (map.size() > BLOCK_CACHE_SIZE) { updateCache(); }
			 */
			this.cleanCache();
			map.put(id, (GBlock) object);
		}

	}

	public void cleanCache() {
		for (String index : map.keySet()) {
			map.get(index).shutdownGB();
		}
		map.clear();
	}

	public GBlock getCache(String id) {
		GBlock gblock = map.get(id);
		if (gblock == null) {
			return null;
		} else {
			return gblock;
		}
		/*
		 * if (object.isExpired()) { map.remove(id); return null; } else {
		 * return object; }
		 */
	}

	public boolean inCacheOrNot(String subgraphID) {
		if (map.containsKey(subgraphID)) {

			return true;
		} else {
			return false;
		}
	}

}
