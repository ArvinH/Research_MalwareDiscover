package netdb.graph.opts.framework;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

import netdb.database.opt.DatabaseOpts;
import netdb.graph.alg.IGraphSearchStrategy;
import netdb.graph.unit.CacheManager;

import com.tinkerpop.blueprints.Vertex;
import com.tinkerpop.blueprints.impls.neo4j.Neo4jGraph;

/**
 * 
 * @author arvin
 * Record the Graphs which are loaded in memory
 */
public class IndexedGraph {
  private CacheManager blockCache = null;
  private Vertex root=null;
  private int queryThreshold;
  private int queryThresholdCounter;
  private String borderID;
  private String firstBorderID;
  private ArrayList<Walker> queryResult;
  
  public IndexedGraph(String firstBorderID){
	 this.blockCache = new CacheManager();
	 this.blockCache.initialCache();
	 queryResult = new ArrayList<Walker>();
	 this.queryThreshold = 0;
	 this.queryThresholdCounter = 0;
	 this.firstBorderID = firstBorderID;
  }
  public Set<Vertex> query(IGraphSearchStrategy queryStrategy, ArrayList<String> queryNodeList) {
	  ArrayList<Walker> walkerList = new ArrayList<Walker>();
	  Walker walker = null;
	  for(int i=0;i < queryNodeList.size(); i++ ){
		  walker = new Walker();
		  walkerList.add(walker);
	  }
	  Iterator<String> queryIterator = queryNodeList.iterator();
	  Iterator<Walker> walkerIterator = walkerList.iterator();
	  //set blockCache for queryStrategey
	  queryStrategy.setCache(this.blockCache);
	  //find all query result
	  while(queryIterator.hasNext() && walkerIterator.hasNext()){
		  //find vertex from GBlock cache
		  root = blockCache.findVertexInCache(queryIterator.next());
		  walker  = walkerIterator.next();
		  queryThreshold = queryStrategy.getStepsThreshold();
		  queryResult.add(queryStrategy.query(root, walker));
	  } 
	  
	  // (for MKNN search)
	  //then compare the intersection of all queryResult
		Iterator<Walker> queryResult_itr = queryResult.iterator();
		Set<Vertex> targetSet = new HashSet<Vertex>();
		while(queryResult_itr.hasNext()){
			targetSet.addAll(queryResult_itr.next().getFoundTargets());
		}
	  

		  /*
			  Vertex nextV = queryStrategy.getNextVisitVertex(root, root, walker);
			  Vertex preV = root;
			  borderID = nextV.getProperty("border");
			  queryThresholdCounter = queryThresholdCounter + 1;
			  if(!borderID.equals("-1")){
				  blockCache.loadGraphToCache(borderID);
				  nextV = blockCache.findVertexInCache((String)nextV.getProperty("Name"));
			  }

			  // if not found K target yet 
			  
			  while (!queryStrategy.successOrNot()) {
				  if (queryThresholdCounter <= queryThreshold){
						  tempV = nextV;
						  nextV = queryStrategy.getNextVisitVertex(nextV, preV, walker);
						  // need check if nextV equals preV or not (means nextV has no edge to walk)
						  if(nextV.equals(preV)){
							  Iterator<Vertex> ptr = preV.getVertices(Direction.BOTH, "vertex").iterator();
							  
							  while(ptr.hasNext()){
								   temp = ptr.next();
								  if(temp.getProperty("walked")){
									  preV = temp;
								  }
							  }
						  }
						  preV = tempV;
						  borderID = nextV.getProperty("border");
						  queryThresholdCounter = queryThresholdCounter + 1; 
						  if(!borderID.equals("-1")){
							  blockCache.loadGraphToCache(borderID);
							  nextV = blockCache.findVertexInCache((String)nextV.getProperty("Name"));
						  } 
							
				  }
				  else{
					  break;
				  }
			 }
			  // while nextV == null
			  // could be situation below:
			   
			   */

	  
	  return targetSet;
  }
  public void Test(){
	  /*
	  Iterator<Edge> itr = indexedGraph.getEdges().iterator();
	  while(itr.hasNext()){
		  System.out.println(itr.next());
	  }
	  */
	  DatabaseOpts databaseOpts = new DatabaseOpts("localhost:3306","graphPartition","root","155013");
  }
  
}
