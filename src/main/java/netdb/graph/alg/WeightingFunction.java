package netdb.graph.alg;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.Iterator;
import java.util.TreeMap;

import netdb.graph.opts.framework.Walker;

import com.tinkerpop.blueprints.Direction;
import com.tinkerpop.blueprints.Edge;
import com.tinkerpop.blueprints.Vertex;

public class WeightingFunction {
	SimpleDateFormat simpleDateFormat;
	static long slidingWindowSize;

	public WeightingFunction(long slidingWindowSize){
		this.simpleDateFormat = new SimpleDateFormat("yyyyMMdd_HHmmss");
		WeightingFunction.slidingWindowSize = slidingWindowSize;
	}
	//update weight for all edges on path to Target
	//according to sliding window(time)
	public void update(Walker walker){
		//should get all path(have target)
		/* need to be implement */
		TreeMap<Integer, ArrayList<Edge>> allPath = walker.getAllPath();
		Vertex edgeInV;
		Vertex edgeOutV;
		for(int key : allPath.keySet()){
			ArrayList<Edge> pathToTarget = allPath.get(key);
			edgeInV = pathToTarget.get(pathToTarget.size()-1).getVertex(Direction.IN);
			edgeOutV = pathToTarget.get(pathToTarget.size()-1).getVertex(Direction.OUT);
			if("1".equals((String)edgeInV.getProperty("type")) || "1".equals((String)edgeOutV.getProperty("type"))){
				Iterator<Edge> edgeptr = pathToTarget.iterator();
				Edge tempEdge;
				String timeStamp;
				ArrayList<String> counting;
				long diff;
				int indexOfcountingString;
				double newWeight;
				while(edgeptr.hasNext()){
					tempEdge = edgeptr.next();
					counting = tempEdge.getProperty("count");
					timeStamp = this.simpleDateFormat.format(Calendar.getInstance().getTime());
						Date currentTime;
						try {
							currentTime = this.simpleDateFormat.parse(timeStamp);
							Date previousTime;
							
							// +=2, because the array would be ['time',count,'time2',count2,...]
							for(indexOfcountingString = 0; indexOfcountingString < counting.size(); indexOfcountingString+=2){
								if(counting.get(indexOfcountingString).contains("_")){
									//timestamp
									previousTime = this.simpleDateFormat.parse(counting.get(indexOfcountingString));
									//diff Minutes
									diff = (currentTime.getTime() - previousTime.getTime()) / (60 * 1000) % 60;
									if(diff < WeightingFunction.slidingWindowSize){
										//do nothing, skip to next counting
									}
									else{
										// calculate the new weight
										newWeight = calculateNewWeight(pathToTarget.size(), pathToTarget.indexOf(tempEdge), Integer.valueOf(counting.get(counting.size()-1)), Integer.valueOf(counting.get(indexOfcountingString+1)));
										tempEdge.setProperty("weight", newWeight);
									}
								}
							}
						} catch (ParseException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
				
				}
			}
			
			
		}
		
	}
	
	private static double calculateNewWeight(int edgeLength, int indexInEdge, int currentCount, int previousCount){
		
		int x = currentCount - previousCount;
		double y;
		double factor;
		y = 1.2*(x/(0.2+x));
		factor = indexInEdge/edgeLength;
		y = y*factor;
		return y;

	}
	
	public static void updateWeight(Edge edge, ArrayList<?> pathToTarget){
		SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyyMMdd_HHmmss");
		String timeStamp;
		ArrayList<String> counting;
		counting = edge.getProperty("count");
		timeStamp = simpleDateFormat.format(Calendar.getInstance().getTime());
		long diff;
		int indexOfcountingString;
		double newWeight;
			Date currentTime;
			try {
				currentTime = simpleDateFormat.parse(timeStamp);
				Date previousTime;
				
				// +=2, because the array would be ['time',count,'time2',count2,...]
				for(indexOfcountingString = 0; indexOfcountingString < counting.size(); indexOfcountingString+=2){
					if(counting.get(indexOfcountingString).contains("_")){
						//timestamp
						previousTime = simpleDateFormat.parse(counting.get(indexOfcountingString));
						//diff Minutes
						diff = (currentTime.getTime() - previousTime.getTime()) / (60 * 1000) % 60;
						if(diff < WeightingFunction.slidingWindowSize){
							//do nothing, skip to next counting
						}
						else{
							// calculate the new weight
								newWeight = calculateNewWeight(pathToTarget.size(), pathToTarget.indexOf(edge), Integer.valueOf(counting.get(counting.size()-1)), Integer.valueOf(counting.get(indexOfcountingString+1)));
								edge.setProperty("weight", newWeight);
						}
					}
				}
			} catch (ParseException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		
	}
	

}