package netdb.graph.unit;

import java.util.Iterator;
import java.util.Map.Entry;
import java.util.TreeMap;

import netdb.graph.opts.framework.GBlock;
import netdb.graph.opts.framework.OptsExperimentSet;

import com.tinkerpop.blueprints.Vertex;
import com.tinkerpop.blueprints.impls.neo4j.Neo4jGraph;

public class CacheManager {
   public static int BLOCK_CACHE_SIZE = 1000;
	private TreeMap<Object, GBlock> map = null;
	private TreeMap<String, Boolean> GraphPartSet = null;
  
  public CacheManager() {
	  map = new TreeMap<Object, GBlock>();
	  GraphPartSet = new TreeMap<String, Boolean>();
	  Iterator<String> GraphPartIDList = OptsExperimentSet.GRAPH_PARTID.iterator();
	  Iterator<String> CachedGraphIDptr = OptsExperimentSet.CACHED_GRAPHID.iterator();
	  while(GraphPartIDList.hasNext()){
		  GraphPartSet.put(GraphPartIDList.next(), false); 
	  }
	  while(CachedGraphIDptr.hasNext()){
		  GraphPartSet.put(CachedGraphIDptr.next(), true); 
	  }
  }
  
  public Vertex findVertexInCache(String vertexName){
	  Iterator<Entry<Object, GBlock>> cacheItr = map.entrySet().iterator();
	  Vertex root;
	  
	  while(cacheItr.hasNext()){
		  root = cacheItr.next().getValue().getGraph().getVertex(vertexName);
		  if(root != null){
			  return root;
		  }
	  }
	  //if vertexName is not in Cache...
	  //check the cache date and use LRU to replace the GBlock
	  
	  
	  
	  return null;
  }
  public void updateCache(){
	  Iterator<Entry<Object, GBlock>> cacheItr = map.entrySet().iterator();
	  Vertex root;
	  
	  while(cacheItr.hasNext()){
		  // check which block should be replace and which block should be put in
		  if(cacheItr.next().getValue().isExpired()){
			  
		  }
		  
	  }
	  
	  
  }
  public void loadGraphToCache(int BorderID){
	  
	  Neo4jGraph indexedGraph = new Neo4jGraph("/graph-"+BorderID);
	  GBlock gBlock = new GBlock(indexedGraph);
	  this.putCache(gBlock);
	  
  }
  public void putCache(Cacheable object)
  {
	  if (map.containsKey(object.getIdentifier())) {
	    /*just update*/
	  }
	  else {
		  if (map.size() > BLOCK_CACHE_SIZE) {
			  cleanCache();
		  }
		  map.put(object.getIdentifier(), (GBlock)object);  
	  }
    
    
  }
  public void cleanCache() {
	  
  }
  public Cacheable getCache(Object identifier)
  {
      Cacheable object = (Cacheable)map.get(identifier);
      if (object == null)
       return null;
      if (object.isExpired())
      {
        map.remove(identifier);
        return null;
      }
      else
      {
        return object;
      }
  }  
}
