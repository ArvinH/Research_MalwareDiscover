'''
@author ArvinH
@date 2014/03/19

'''
import sys
import random
import postgresql
import pg_deletePartFromOrigraph
import pdb
import time

class partition:
   def __init__(self, depth):
        self.partID = 0
        self.count = 0
        self.depth = int(depth)
        self.borderOrNot = 0
        self.nodeDict = dict()
        self.edgeSet = set()
        self.targetLists = list()
   def run(self,targetList,edgefile):

            with open(targetList,'r',encoding='utf-8') as targetFile:
                  for line in targetFile:
                     data = line.strip().split('\t')
                     self.targetLists.append(data[0])


            D = pg_deletePartFromOrigraph.disk_deletePartFromOriGraph()
            singleNodeOrNot = ''
            for target in self.targetLists:
                f = open('/home/arvin/Dropbox/Research/GTgraph-master/R-MAT/processRealDataProgram/RealData/mini_edge/'+str(self.partID)+'_part','w',encoding='utf-8')
                f2 = open('/home/arvin/Dropbox/Research/GTgraph-master/R-MAT/processRealDataProgram/RealData/mini_node/'+str(self.partID)+'_part.node', 'w', encoding='utf-8')
                f.write('nodeID:string:Nodes\tnodeID:string:Nodes\tlabel\twalked\tweight\tcount\tsubgraphID'+'\n')
                f2.write('nodeID:string:Nodes\ttype\tcount\twalked\tLandMark\tsubgraphID'+'\n')
                singleNodeOrNot = self.expansion('-1',target, self.count, self.depth, f, f2, self.partID)
                f2.write(str(target)+'\t'+'1'+'\t'+'0'+'\t'+'0'+'\t'+'0'+'\t'+str(self.partID)+'\n')
                self.printNode(f2)
                self.nodeDict[str(target)] = str(self.partID)
                self.updateBorderMap()
                self.nodeDict = dict()
                self.edgeSet = set()
                f.close()
                f2.close()
                if singleNodeOrNot != -1:
                    #D.delete('/Volumes/MacintoshHDD/Users/arvin/Dropbox/Research/GTgraph-master/R-MAT/processSyntheticDataProgram/generateData/'+str(self.partID)+'_part')
                    D.delete(str(self.partID)+'_part')
                elif singleNodeOrNot == -1:
                    #D.deleteSingle('/Volumes/MacintoshHDD/Users/arvin/Dropbox/Research/GTgraph-master/R-MAT/processSyntheticDataProgram/generateData/'+str(self.partID)+'_part', target)
                    D.deleteSingle(str(self.partID)+'_part', target)
                self.partID = self.partID + 1






   def expansion(self, preNode, target, currentCount, depth, f, f2, subgraphID):
             db = postgresql.open(user = 'netdb', password = 'netdb',host = '192.168.66.42', database = 'mrGraph4', port = 5432)
             get_neighbor = db.prepare('select neighbor,valid from neighborMap where nodeID = $1')
             with db.xact():
               result = get_neighbor(target)
               if currentCount >= depth:
                  #check if it is border(has neighbors)
                  #has neighbor: return 1, others return 0
                  if result[0][1] != '1':
                    if len(result[0]) != 0:
                       neighbors = result[0][0]
                       return 1
                    else:
                       return 0

               if result[0][1] != '1':
                  if len(result[0]) != 0:
                    if result[0][0] != '':
                        neighbors = result[0][0].split(',')
                        for nextNode in neighbors:
                           if (preNode == nextNode) and (preNode != '-1'):
                             pass
                           elif nextNode in self.nodeDict:  #avoiding loop
                             #add the edge or not? yes!
                             #but..when to add edge? think about one node link to pre-level's node -> will have duplicate edge
                             f.write(str(target)+'\t'+str(nextNode)+'\t'+'edge_label'+'\t'+'0'+'\t'+'1'+'\t'+'0'+'\t'+str(subgraphID)+'\n')
                             self.addEdge(str(target)+'_'+str(nextNode))
                             pass
                           elif nextNode in self.targetLists:
                             pass
                           else:
                             currentCount = currentCount + 1
                             tempNode = preNode
                             preNode = target
                             self.borderOrNot = self.expansion(preNode, nextNode, currentCount, depth, f, f2, subgraphID)
                             preNode = tempNode
                             if (currentCount == depth) and (self.borderOrNot == 1):
                                self.addNode(str(nextNode), f2, str(subgraphID))
                                f.write(str(target)+'\t'+str(nextNode)+'\t'+'edge_label'+'\t'+'0'+'\t'+'1'+'\t'+'0'+'\t'+str(subgraphID)+'\n')
                                self.addEdge(str(target)+'_'+str(nextNode))
                             else:
                                get_subgraph = db.prepare('select subgraphID from borderMap where borderID = $1')
                                with db.xact():
                                  result2 = get_subgraph(str(nextNode))
                                  if len(result2) != 0:
                                     self.addNode(str(nextNode), f2, str(subgraphID))
                                     f.write(str(target)+'\t'+str(nextNode)+'\t'+'edge_label'+'\t'+'0'+'\t'+'1'+'\t'+'0'+'\t'+str(subgraphID)+'\n')
                                     self.addEdge(str(target)+'_'+str(nextNode))
                                  else:
                                     self.addNode(str(nextNode), f2, '-1')
                                     f.write(str(target)+'\t'+str(nextNode)+'\t'+'edge_label'+'\t'+'0'+'\t'+'1'+'\t'+'0'+'\t'+'-1'+'\n')
                                     self.addEdge(str(target)+'_'+str(nextNode))
                             currentCount = currentCount - 1
                    elif result[0][0] == '' and preNode == '-1':
                        return -1
               elif len(result) == 0 and preNode == '-1':
                        return -1


             return 0

   def updateBorderMap(self):
             db = postgresql.open(user = 'netdb', password = 'netdb',host = '192.168.66.42', database = 'mrGraph4', port = 5432)
             #insert into borderMap -> record border's neighbors in borderMap
             for nodeKey in self.nodeDict:
                if self.nodeDict[nodeKey] != '-1':
                  newSubgraphID = str(self.nodeDict[nodeKey])

                  get_subgraph = db.prepare('select subgraphID from borderMap where borderID = $1')
                  with db.xact():
                    result2 = get_subgraph(str(nodeKey))
                    if len(result2) != 0:
                       if len(result2[0]) != 0:
                          ori_subgraphID = result2[0][0]
                          newSubgraphID = ori_subgraphID+','+str(self.nodeDict[nodeKey])

                  get_neighbor = db.prepare('select neighbor,valid from neighborMap where nodeID = $1')
                  with db.xact():
                    result = get_neighbor(str(nodeKey))
                    if result[0][1] != '1':
                       if len(result[0]) != 0:
                           neighbors = result[0][0]
                           get_borderID = db.prepare('select borderID from borderMap where borderID = $1')
                           with db.xact():
                             result3 = get_borderID(str(nodeKey))
                             if len(result3) > 0:
                               #update
                               update_border = db.prepare('update borderMap set neighbor = $2, subgraphID = $3 where borderID = $1')
                               with db.xact():
                                 update_border(str(nodeKey), neighbors, newSubgraphID)
                             else:
                               #insert
                               insert_border = db.prepare('insert into borderMap values($1,$2,$3)')
                               with db.xact():
                                 insert_border(str(nodeKey), neighbors, newSubgraphID)


   def addNode(self, nextNode, f2, subgraphID):
      if nextNode not in self.nodeDict:
         #f2.write(nextNode+'\t'+'0'+'\t'+'0'+'\t'+'0'+'\t'+subgraphID+'\n')
         self.nodeDict[nextNode] = subgraphID
      else:
         if subgraphID == '-1':
            self.nodeDict[nextNode] = subgraphID
        #   f2.write(nextNode+'\t'+'0'+'\t'+'0'+'\t'+'0'+'\t'+subgraphID+'\n')
   def addEdge(self, EDGE):
      if EDGE not in self.edgeSet:
         self.edgeSet.add(EDGE)
      else:
        pass

   def printNode(self,f2):
      for nodeKey in self.nodeDict:
        f2.write(str(nodeKey)+'\t'+'0'+'\t'+'0'+'\t'+'0'+'\t'+'0'+'\t'+str(self.nodeDict[nodeKey])+'\n')





def main ():
    targetList = sys.argv[1]
    edgefile = sys.argv[2]
    depth = sys.argv[3]
    f = partition(depth)
    startTime = time.time()
    f.run(targetList,edgefile)
    endTime = time.time()
    diff = endTime - startTime
    print('total time: '+str(diff))



if __name__ == '__main__' :
    main()
