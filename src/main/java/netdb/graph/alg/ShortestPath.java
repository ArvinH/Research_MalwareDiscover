package netdb.graph.alg;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Properties;

import netdb.graph.opts.framework.GBlock;
import netdb.graph.opts.framework.OptsExperimentSet;
import netdb.graph.unit.CacheManager;

import com.tinkerpop.blueprints.Edge;
import com.tinkerpop.blueprints.Vertex;
import com.tinkerpop.blueprints.impls.neo4j.Neo4jGraph;
import com.tinkerpop.blueprints.oupls.jung.GraphJung;

import edu.uci.ics.jung.algorithms.shortestpath.DijkstraShortestPath;

public class ShortestPath {
	private CacheManager blockCache = null;
	private TargetMonitor targetMonitor = null;
	public ShortestPath(){
		
		Properties prop = new Properties();
    	try {
          prop.load(new FileInputStream("/Volumes/MacintoshHDD/Users/arvin/git/Research_MalwareDiscover/src/main/java/netdb/graph/properties/config.properties"));
          
          String[] targetList = prop.getProperty("TARGET_VERTEXID").split(",");
          OptsExperimentSet.TARGET_LIST = targetList;
          String[] GraphPartIDListString = prop.getProperty("GRAPH_PARTID").split(",");
          OptsExperimentSet.GRAPH_PARTID = GraphPartIDListString;
    	} catch (IOException e) {
    		e.printStackTrace();
    	}	
    	
    	this.blockCache = new CacheManager();
    	this.targetMonitor = new TargetMonitor(this.blockCache);
	}
	/**
	 * 
	 * @param queryNode
	 * @param targetNode
	 * @param K for query times
	 */
	public void run(HashMap<String,String> queryNode, LinkedList<String> targetNode, int K){ 
		Iterator<String> queryItr = queryNode.keySet().iterator();
		String rootKey = null;
		String[] rootV = null;
		String timestamp = null;
		Vertex root = null;
		Vertex target = null;
		GBlock gblock = null;
		List<Edge> spResult = null;
		
		HashSet<Vertex> finalResult = new HashSet<Vertex>();
		ValueComparator vc = new ValueComparator();  
		while(queryItr.hasNext()){
			rootKey = queryItr.next();
			rootV = queryNode.get(rootKey).split("_");
			root = this.blockCache.findVertexInCache(rootV[0]);
			timestamp = rootV[1];
			HashMap<Vertex, Integer> lengthMap = new HashMap<Vertex, Integer>();
			for(String targetV : targetNode){
				target = this.blockCache.findVertexInCache(targetV);
				gblock = (GBlock)this.blockCache.getCache("single-L");
				GraphJung<Neo4jGraph> gj = new GraphJung<Neo4jGraph>(gblock.getGraph());
				DijkstraShortestPath<Vertex, Edge> dsp = new DijkstraShortestPath<Vertex, Edge>(gj);
				spResult = dsp.getPath(root, target);
				//compare length
				lengthMap.put(target, spResult.size());
			}
			List<Map.Entry<Vertex,Integer>> sort=new ArrayList<>(); 
			sort.addAll(lengthMap.entrySet()); 
	        Collections.sort(sort,vc); 
			Iterator<Map.Entry<Vertex,Integer>> spRptr = sort.iterator();
			int counter = K;
			int targetPathLength;
			Vertex foundTarget = null;
			String targetCount_str = null;
			ArrayList<String> targetCount = new ArrayList<String>();
			while(spRptr.hasNext() && counter > 0){
				foundTarget = spRptr.next().getKey();
				targetPathLength = lengthMap.get(foundTarget);
				finalResult.add(foundTarget);
				if(String.class.isAssignableFrom(foundTarget.getProperty("count").getClass())){
					targetCount_str = foundTarget.getProperty("count");
					targetCount.add(timestamp);
					targetCount.add(String.valueOf(Integer.parseInt(targetCount_str)+1));
					foundTarget.setProperty("count", targetCount);
				}
				counter = counter - 1;
			}
			for(Vertex v : finalResult){
				for(Vertex tv : lengthMap.keySet()){
					if(tv.getProperty("nodeID").equals(v.getProperty("nodeID"))){
						System.out.println("target found: ,"+v.getProperty("nodeID")+", length = "+lengthMap.get(tv));
					}
				}
			}
			System.out.println("xxxxxxxx");
			
		}
		
		
		
	}
	public void targetMonitor(){
		this.targetMonitor.monitor();
	}
	private static class ValueComparator implements Comparator<Map.Entry<Vertex,Integer>>  
    {  
        public int compare(Map.Entry<Vertex,Integer> m,Map.Entry<Vertex,Integer> n)  
        {  
            return m.getValue()-n.getValue();  
        }  
    }  
	public static void main(String[] agrs) {
		ShortestPath sp = new ShortestPath();
		HashMap<String,String> queryNodeList = new HashMap<String,String>();
		LinkedList<String> targetNodeList = new LinkedList<String>();
		for(String target : OptsExperimentSet.TARGET_LIST){
			targetNodeList.add(target);
		}
		
		String prefixfileName = "/Volumes/MacintoshHDD/Users/arvin/Dropbox/Research/batch-import/ResearchSyntheticData/syntheticData/";
		String fileName = prefixfileName + "queryList5.csv";
		int i = 0;
		try {
			FileReader fr = new FileReader(fileName);
			BufferedReader br = new BufferedReader(fr);
			String line;
			while((line = br.readLine())!=null){
					System.out.println(line);
					queryNodeList.put(String.valueOf(i),line+"_2014-01-21 09:54:26");
					i = i + 1;
			}
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}catch (IOException e) {
			e.printStackTrace();
		}
		
		Date startTime = Calendar.getInstance().getTime();
		sp.run(queryNodeList,targetNodeList,3);
		Date currentTime = Calendar.getInstance().getTime();
		long diff = (currentTime.getTime() - startTime.getTime()) / 1000;
		System.out.println("Total time: "+diff);
		
		//show all target's status
		sp.targetMonitor();
		sp.blockCache.cleanCache();
	}
	

}
