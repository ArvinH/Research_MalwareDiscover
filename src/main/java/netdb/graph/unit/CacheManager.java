package netdb.graph.unit;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map.Entry;
import java.util.TreeMap;

import netdb.graph.opts.framework.GBlock;
import netdb.graph.opts.framework.OptsExperimentSet;

import com.tinkerpop.blueprints.Vertex;
import com.tinkerpop.blueprints.impls.neo4j.Neo4jGraph;

public class CacheManager {
    public static int BLOCK_CACHE_SIZE = 1000;
	private TreeMap<String, GBlock> map = null;
	private HashMap<String,Boolean> GraphPartSet = null;
  
  public CacheManager() {
	  map = new TreeMap<String, GBlock>();
	  GraphPartSet = new HashMap<String,Boolean>();
	  Iterator<String> GraphPartIDList = OptsExperimentSet.GRAPH_PARTID.iterator();
	  Iterator<String> CachedGraphIDptr = OptsExperimentSet.CACHED_GRAPHID.iterator();
	  //initial false value to all id in Set
	  while(GraphPartIDList.hasNext()){
		  GraphPartSet.put(GraphPartIDList.next(),false); 
	  }
	  //set value to true according to CachedGraphID
	  while(CachedGraphIDptr.hasNext()){
		  GraphPartSet.put(CachedGraphIDptr.next(),true); 
	  }
  }
  public void initialCache(){
	  for(String putOrNot : GraphPartSet.keySet()){
		  if(GraphPartSet.get(putOrNot)){
			  loadGraphToCache(putOrNot);
		  }
	  }
  	  
  }
  
  public Vertex findVertexInCache(String vertexName){
	  Iterator<Entry<String, GBlock>> cacheItr = map.entrySet().iterator();
	  Vertex root;
	  
	  while(cacheItr.hasNext()){
		  root = cacheItr.next().getValue().getGraph().getVertex(vertexName);
		  if(root != null){
			  return root;
		  }
		  //if vertexName is not in Cache...
		  //check the cache date and use LRU to replace the GBlock
		  this.updateCache();
	  }
	  
	  
	  
	  
	  return null;
  }
  public void updateCache(){
	  Iterator<Entry<String, GBlock>> cacheItr = map.entrySet().iterator();
	  Entry<String, GBlock> tempEntry;
	  
	  while(cacheItr.hasNext()){
		  // check which block should be replace and which block should be put in
		  tempEntry = cacheItr.next();
		  if(tempEntry.getValue().isExpired()){
			  //remove the expired GBlock
			  map.remove(tempEntry.getValue());
			  
			  //which gblock should be update into cache?
			  
			  for(String PartID : GraphPartSet.keySet()){
				  if(!GraphPartSet.get(PartID)){
					  loadGraphToCache(PartID);
					  GraphPartSet.put(PartID, true);
				  }
			  }
			  //And set its partID to false in GraphPartSet
			  GraphPartSet.put(tempEntry.getKey(), false);
		  }
		  
	  }
	  
	  
  }
  public void loadGraphToCache(String BorderID){
	  
	  Neo4jGraph indexedGraph = new Neo4jGraph("/graph-"+BorderID);
	  GBlock gBlock = new GBlock(indexedGraph,BorderID);
	  this.putCache(gBlock);
	  
  }
  public void putCache(Cacheable object)
  {
	  if (map.containsKey(object.getIdentifier())) {
	    /*just update*/
	  }
	  else {
		  if (map.size() > BLOCK_CACHE_SIZE) {
			  updateCache();
		  }
		  map.put(object.getIdentifier(), (GBlock)object);  
	  }
    
    
  }
  
  public void cleanCache() {
	  map.clear();
  }
  
  public Cacheable getCache(Object identifier)
  {
      Cacheable object = (Cacheable)map.get(identifier);
      if (object == null)
       return null;
      if (object.isExpired())
      {
        map.remove(identifier);
        return null;
      }
      else
      {
        return object;
      }
  }  
}
