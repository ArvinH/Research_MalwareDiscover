package netdb.graph.alg;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.HashMap;
import java.util.Iterator;

import netdb.graph.opts.framework.TargetNode;

import com.tinkerpop.blueprints.Direction;
import com.tinkerpop.blueprints.Edge;
import com.tinkerpop.blueprints.Vertex;

public class BoundaryProccessor {
	private final double threshold;
	private Vertex target;
	private HashMap<Vertex, TargetNode<Vertex>> targetBoundaryTree;
	public BoundaryProccessor(double threshold){
		this.threshold = threshold;
	}
	public void setTarget(Vertex target){
		this.target = target;
		//will be new every time I setTarget, so may be need to be modify to save memory
		//but don't consider it now...
		this.targetBoundaryTree = new HashMap<Vertex, TargetNode<Vertex>>();
	}
	
	public void setupBoundary(Vertex target, double probNow){
		// start to record target boundary tree
		TargetNode<Vertex> targetRoot = new TargetNode<Vertex>(target);
		this.targetBoundaryTree.put(target, targetRoot);
		
		Iterator<Edge> firstlevelEdge = target.getEdges(Direction.BOTH, "edge_label").iterator();
		Edge edge;
		Vertex vertex;
		Edge e;
		RandomProb RProb = new RandomProb();	
		while(firstlevelEdge.hasNext()){
			edge = firstlevelEdge.next();	
			if(edge.getVertex(Direction.IN) != null && !edge.getVertex(Direction.IN).equals(target)){
				vertex = edge.getVertex(Direction.IN);
				Iterator<Edge> secondlevelEdge = vertex.getEdges(Direction.BOTH, "edge_label").iterator();
				//find the prob of every edge
				double sumOfweightingValue = 0;
				while (secondlevelEdge.hasNext()){
					e = secondlevelEdge.next();
					sumOfweightingValue = sumOfweightingValue + (Double)e.getProperty("weight");
				}
					// here to decide which edge should be walked
				probNow = probNow *= RProb.probToTarget(sumOfweightingValue,edge);
				if( probNow < threshold){
					vertex.setProperty("LandMark",true);
					vertex.addEdge("attachedTarget", target);
					return;
				}
				else{
					TargetNode<Vertex> child = new TargetNode<Vertex>(vertex);
					targetRoot.insertChild(child);
					updateBoundary(vertex, edge, probNow, child);
				}
			}
			if(edge.getVertex(Direction.OUT) != null && !edge.getVertex(Direction.OUT).equals(target)){
				vertex = edge.getVertex(Direction.OUT);
				Iterator<Edge> secondlevelEdge = vertex.getEdges(Direction.BOTH, "edge_label").iterator();
				//find the prob of every edge
				double sumOfweightingValue = 0;
				while (secondlevelEdge.hasNext()){
					e = secondlevelEdge.next();
					sumOfweightingValue = sumOfweightingValue + (Double)e.getProperty("weight");
				}
					// here to decide which edge should be walked
				probNow = probNow *= RProb.probToTarget(sumOfweightingValue,edge);
				if( probNow < threshold){
					vertex.setProperty("LandMark",true);
					vertex.addEdge("attachedTarget", target);
					return;
				}
				else{
					TargetNode<Vertex> child = new TargetNode<Vertex>(vertex);
					targetRoot.insertChild(child);
					updateBoundary(vertex, edge, probNow, child);
				}
			}
		}
	}
	
	public void updateBoundary(Vertex oriV,Edge oriE, double probNow, TargetNode<Vertex> node){
		Iterator<Edge> levelEdge = oriV.getEdges(Direction.BOTH, "edge_label").iterator();
		Edge edge;
		Edge e;
		Vertex vertex;
		RandomProb RProb = new RandomProb();
		while(levelEdge.hasNext()){
			edge = levelEdge.next();	
			if((oriE != null) && edge.equals(oriE)){ //skip oriE
				edge = levelEdge.next();
			}
			if(edge.getVertex(Direction.IN) != null && !edge.getVertex(Direction.IN).equals(oriV)){
				vertex = edge.getVertex(Direction.IN);
				Iterator<Edge> secondlevelEdge = vertex.getEdges(Direction.BOTH, "edge_label").iterator();
				//find the prob of every edge
				double sumOfweightingValue = 0;
				while (secondlevelEdge.hasNext()){
					e = secondlevelEdge.next();
					sumOfweightingValue = sumOfweightingValue + (Double)e.getProperty("weight");
				}
					// here to decide which edge should be walked
				probNow = probNow *= RProb.probToTarget(sumOfweightingValue,edge);
				if( probNow < threshold){
					oriV.setProperty("LandMark",true);
					oriV.addEdge("attachedTarget", target);
					return;
				}
				else{
					TargetNode<Vertex> child = new TargetNode<Vertex>(vertex);
					node.insertChild(child);
					updateBoundary(vertex, edge, probNow, child);
				}
				
			}
			if(edge.getVertex(Direction.OUT) != null && !edge.getVertex(Direction.OUT).equals(oriV)){
				vertex = edge.getVertex(Direction.IN);
				Iterator<Edge> secondlevelEdge = vertex.getEdges(Direction.BOTH, "edge_label").iterator();
				//find the prob of every edge
				double sumOfweightingValue = 0;
				while (secondlevelEdge.hasNext()){
					e = secondlevelEdge.next();
					sumOfweightingValue = sumOfweightingValue + (Double)e.getProperty("weight");
				}
					// here to decide which edge should be walked
				probNow = probNow *= RProb.probToTarget(sumOfweightingValue,edge);
				if( probNow < threshold){
					oriV.setProperty("LandMark",true);
					oriV.addEdge("attachedTarget", target);
					return;
				}
				else{
					TargetNode<Vertex> child = new TargetNode<Vertex>(vertex);
					node.insertChild(child);
					updateBoundary(vertex, edge, probNow, child);
				}
			}
		}
		return; // back to last level
	}
	public void updateWeightbetweenTargetandBoundary(Vertex vertex, Vertex target) {

		TargetNode<Vertex> targetnode = this.targetBoundaryTree.get(target);
		ArrayList<Vertex> pathTotarget_vertex = new ArrayList<Vertex>();
		ArrayList<Edge> pathTotarget_edge = new ArrayList<Edge>();
		//find the path between target and vertex
		targetnode.search(targetnode,vertex,pathTotarget_vertex);
		Vertex vstart;	
		Vertex vend;
		Iterator<Edge> edgeptr;
		Edge e1;
		ArrayList<String> counting;
		String timeStamp = null;
		int count = 0;
		//transform the pathTotarget_vertex list to pathTotarget_edge
		for(int i = 0; i < pathTotarget_vertex.size(); i++){
			if((i+1) < pathTotarget_vertex.size()){
				vstart = pathTotarget_vertex.get(i);
				vend = pathTotarget_vertex.get(i+1);
			
				edgeptr = vstart.getEdges(Direction.BOTH, "edge_label").iterator();
				while(edgeptr.hasNext()){
					e1 = edgeptr.next();
					if(e1.getVertex(Direction.OUT).equals(vend) || e1.getVertex(Direction.IN).equals(vend)){
						//add the edge's count first
						counting = e1.getProperty("count");
						count = Integer.valueOf(counting.get(counting.size()-1));
						timeStamp= new SimpleDateFormat("yyyyMMdd_HHmmss").format(Calendar.getInstance().getTime());
						counting.add(timeStamp);
						counting.add(String.valueOf(count+1));
						e1.setProperty("count",counting);
						//add edge path into pathTotarget_edge list and then pass it to WeightingFunction.updateWeight
						pathTotarget_edge.add(e1);
					}
				}
			}
			else if((i+1) >= pathTotarget_vertex.size()){
				// do nothing
				
			}
		}
			//increase count on this edge, and update it's weight
		for(int j = 0; j < pathTotarget_edge.size(); j++){
			e1 = pathTotarget_edge.get(j);
			WeightingFunction.updateWeight(e1, pathTotarget_edge);
		}
			
		
	}

}
