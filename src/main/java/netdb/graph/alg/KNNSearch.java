package netdb.graph.alg;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.TreeSet;

import netdb.graph.opts.framework.TargetVertex;
import netdb.graph.opts.framework.Walker;
import netdb.graph.unit.EdgesCollection;
import netdb.graph.unit.VerticesCollection;

import com.tinkerpop.blueprints.Direction;
import com.tinkerpop.blueprints.Edge;
import com.tinkerpop.blueprints.Vertex;
/**
 * 
 * @author arvin
 * KNN Search Strategy
 */
public class KNNSearch implements IGraphSearchStrategy{
	private TreeSet<Vertex> knnCandidate;
    private IGraphSearchVisitor Ivisitor;
    private ArrayList<Vertex> adjacentVertices;
    private ArrayList<Edge> EdgeList;
    private RandomProb RProb;
    private boolean stopOrNot = false;
    private boolean foundTargetOrNot = false;
    private int probthreshold = 0;
    private int Stepsthreshold = 0;
    private int K;
    private Vertex returnVertex;
    public KNNSearch(int Stepsthreshold, int k){
    	knnCandidate = new TreeSet<Vertex>();
    	this.Stepsthreshold = Stepsthreshold;
    	adjacentVertices = new ArrayList<Vertex>();
    	EdgeList = new ArrayList<Edge>();
    	RProb = new RandomProb();
    	this.K = k;
    }
    
	public Vertex getNextVisitVertex(Vertex lastV, Walker walker) {
		// calculate the probability of walking to or not walking to v's neighbors
		// pick one v from lastV

		// collect all adjacent vertices and edges
		adjacentVertices.addAll(VerticesCollection.convert(lastV.getVertices(Direction.BOTH, "edge labels")));
		EdgeList.addAll(EdgesCollection.convert(lastV.getEdges(Direction.BOTH, "edge labels")));
		
		Iterator<Edge> edgePtr = EdgeList.iterator();
		double prob = 0.0;
		double tempProb = 0.0;
		Edge e = null;
		
		//find the most prob to walk
		while (edgePtr.hasNext()){
			e = edgePtr.next();
			double weight = e.getProperty("weight");
			// here to decide which edge should be walked
			tempProb = RProb.calculate(weight);
			if(tempProb > prob){
				prob = tempProb;
			}
		}
		
			if(prob > probthreshold){
				
				Vertex vIn = e.getVertex(Direction.IN);
				Vertex vOut = e.getVertex(Direction.OUT);
				if(lastV.equals(vIn)){
					foundTargetOrNot = Ivisitor.visitVertex(vOut, e, walker);
					returnVertex = vOut;
				}
				else if(lastV.equals(vOut)){
					foundTargetOrNot = Ivisitor.visitVertex(vIn, e, walker);
					returnVertex = vIn;
				}
				
			}
			//if prob too small, then get another Vertex
			
			//check if visitor found the target or not, then keep finding(go back to find)
			if(foundTargetOrNot){
				knnCandidate.add(walker.getLeastNode());
				//keep finding
				return returnVertex;
			}
			else if(!foundTargetOrNot){
				//keep finding
				return returnVertex;
			}
		
		
		//no edge can walk
		//do what??
		
		
		return null;
	}

	public int getStepsThreshold(){
		return this.Stepsthreshold;
	}
	public void accept(IGraphSearchVisitor vis) {
		Ivisitor = vis;
		
	}

	@Override
	public boolean successOrNot() {
		// TODO Auto-generated method stub
		if(knnCandidate.size() == this.K){
			return true;
		}
		else{
			return false;
		}
	}


}
