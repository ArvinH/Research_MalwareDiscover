package netdb.graph.alg;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Properties;
import java.util.TreeMap;

import netdb.graph.opts.framework.OptsExperimentSet;

import com.tinkerpop.blueprints.Direction;
import com.tinkerpop.blueprints.Vertex;
import com.tinkerpop.blueprints.impls.neo4j.Neo4jGraph;

public class Naive_bfs {
	//private String BorderID = "RealSingle-newWeight";
		private String BorderID = "RealSingle-newbfs";
		private Neo4jGraph indexedGraph = null;
		private TargetMonitor targetMonitor = null;
		private HashSet<Vertex> walkedV = null;
		private boolean foundOrNot = false;
		public Naive_bfs(){
			walkedV = new HashSet<Vertex>();
			Properties prop = new Properties();
			try {
				prop.load(new FileInputStream("C:\\Program Files\\Neo4j Community\\confignewbfs.properties"));
				String[] targetList = prop.getProperty("TARGET_VERTEXID").split(",");
				OptsExperimentSet.TARGET_LIST = targetList;
			} catch (FileNotFoundException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			//String prefix = "home/arvin/neo4j-community-1.9.7/data/";
			  //String prefix = "/Volumes/MacintoshHDD/Users/arvin/Documents/neo4j-community-1.9.7/data/";
			  String prefix = "C:\\Program Files\\Neo4j Community\\";
			  HashMap<String, String> config = new HashMap<String, String>();
			  config.put("online_backup_enabled", "false"); 
			  config.put("cache_type", "soft");
			  this.indexedGraph = new Neo4jGraph(prefix+"graph-"+BorderID+".db", config);
			  this.targetMonitor = new TargetMonitor(this.indexedGraph);
		}
		public void shutdownGraph(){
			this.indexedGraph.shutdown();
		}
		public void start(TreeMap<Integer,String> queryNode){
			
			String[] currentQueryNodeContent = null;
			Iterator<Integer> queryPtr = queryNode.keySet().iterator();
			while(queryPtr.hasNext()){
				currentQueryNodeContent = queryNode.get(queryPtr.next()).split("_");
				Iterator<Vertex> tempVertex = this.indexedGraph.getVertices("nodeID", currentQueryNodeContent[0]).iterator();
				Vertex returnVertex = null;
				while(tempVertex.hasNext()){
					returnVertex = tempVertex.next();
				}
				if(returnVertex == null){
					System.out.println(currentQueryNodeContent[0] + " not found");
				}
				else{
					explore(returnVertex, null, currentQueryNodeContent[1]);
				}
			}
			this.targetMonitor.monitorForbfs();
			
		}
		public void explore(Vertex v, Vertex lastV, String timeStamp){
				this.walkedV.add(v);
				Iterator<Vertex> tempVList = null;
				tempVList = v.getVertices(Direction.BOTH, "edge_label").iterator();
				Vertex tempV;
				ArrayList<String> counting;
			  	int targetCount;
				while(tempVList.hasNext() && !this.foundOrNot){
					tempV = tempVList.next();
					if(!tempV.equals(lastV) && !this.walkedV.contains(tempV)){
						if("1".equals(tempV.getProperty("type"))){
							if(String.class.isAssignableFrom(tempV.getProperty("count").getClass())){
				  				targetCount = 1; 
								ArrayList<String> newcounting = new ArrayList<String>();
								newcounting.add(timeStamp);
								newcounting.add(String.valueOf(targetCount));
								tempV.setProperty("count",newcounting);
							}
							else{
								counting = tempV.getProperty("count"); 
								targetCount = Integer.parseInt(counting.get(counting.size()-1));
								counting.add(timeStamp);
								counting.add(String.valueOf(targetCount+1));
								tempV.setProperty("count",counting);
							}
							this.foundOrNot = true;
							return;
						}
						else{
							explore(tempV,v,timeStamp);
						}
					}
					
				}
			
		}
		
		public static void main(String[] agrs) {
			Naive_bfs naive_bfs = new Naive_bfs();
			
			TreeMap<Integer, String> queryNodeList = new TreeMap<Integer,String>();
			//String prefixfileName = "/home/arvin/Dropbox/Research/batch-import/ResearchReal_Query/";
			//String prefixfileName = "/Volumes/MacintoshHDD/Users/arvin/Dropbox/Research/batch-import/ResearchReal_Query/";
			String prefixfileName = "C:\\Program Files\\Neo4j Community\\ResearchReal_Query\\";
			String fileName = prefixfileName + "finalquerylog.list";
			int i = 0;
			try {
				FileReader fr = new FileReader(fileName);
				BufferedReader br = new BufferedReader(fr);
				String line, linearray[];
				String query_time, qfilesha1, qsamplesha1, qdomain, qip;
				while((line = br.readLine())!=null){
						// split line to get query terms
						linearray = line.split("\t");
						query_time = linearray[0];
						qfilesha1 = linearray[1];
						qsamplesha1 = linearray[2];
						qdomain = linearray[3];
						qip = linearray[4];
						if(!"None".equals(qfilesha1)){
							qfilesha1 = qfilesha1.replace("[", "");
							qfilesha1 = qfilesha1.replace("]", "");
							qfilesha1 = qfilesha1.replace(" ", "");
							String[] qfileshalist = qfilesha1.split(",");
							for(String qfilesha1_term : qfileshalist){
								queryNodeList.put(i,qfilesha1_term+"_"+query_time);
								i=i+1;
							}
						}
						if(!"None".equals(qsamplesha1)){
							qsamplesha1 = qsamplesha1.replace("[", "");
							qsamplesha1 = qsamplesha1.replace("]", "");
							qsamplesha1 = qsamplesha1.replace(" ", "");
							String[] qsampleshalist = qsamplesha1.split(",");
							for(String qsamplesha1_term : qsampleshalist){
								queryNodeList.put(i,qsamplesha1_term+"_"+query_time);
								i=i+1;
							}
						}
						if(!"None".equals(qdomain)){
							queryNodeList.put(i,qdomain+"_"+query_time);
							i = i +1;
						}
						if(!"None".equals(qip)){
							queryNodeList.put(i,qip+"_"+query_time);
							i = i + 1;
						}
						
				}
				br.close();
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			}catch (IOException e) {
				e.printStackTrace();
			}
			Date startTime = Calendar.getInstance().getTime();
			naive_bfs.start(queryNodeList);
			Date currentTime = Calendar.getInstance().getTime();
			long diff = (currentTime.getTime() - startTime.getTime()) / 1000;
			System.out.println("Total time: "+diff);
			
			naive_bfs.shutdownGraph();
		}
}
