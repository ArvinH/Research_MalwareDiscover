package netdb.graph.unit;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.TreeMap;

import netdb.graph.opts.framework.GBlock;
import netdb.graph.opts.framework.OptsExperimentSet;

import org.neo4j.graphdb.GraphDatabaseService;
import org.neo4j.graphdb.factory.GraphDatabaseFactory;

import com.tinkerpop.blueprints.Vertex;
import com.tinkerpop.blueprints.impls.neo4j.Neo4jGraph;

public class CacheManager {
    public static int BLOCK_CACHE_SIZE = 1000;
	private TreeMap<String, GBlock> map = null;
	private HashMap<String,Boolean> GraphPartSet = null;
  
  public CacheManager() {
	  map = new TreeMap<String, GBlock>();
	  GraphPartSet = new HashMap<String,Boolean>();
	  String[] GraphPartIDList = OptsExperimentSet.GRAPH_PARTID;
	  String[] CachedGraphIDptr = OptsExperimentSet.CACHED_GRAPHID;
	  //initial false value to all id in Set
	  for(String id : GraphPartIDList){
		  GraphPartSet.put(id,false);
	  }
	 
	  //set value to true according to CachedGraphID
	  for(String id : CachedGraphIDptr){
		  GraphPartSet.put(id,true);
	  }
	  
  }
  public void initialCache(){
	  for(String putOrNot : GraphPartSet.keySet()){
		  if(GraphPartSet.get(putOrNot)){
			  loadGraphToCache(putOrNot);
		  }
	  }
  	  
  }
  
  public Vertex findVertexInCache(String vertexID){
	  Iterator<Entry<String, GBlock>> cacheItr = map.entrySet().iterator();
	  Vertex root;
	  
	  while(cacheItr.hasNext()){
		  root = cacheItr.next().getValue().getGraph().getVertex(vertexID);
		  if(root != null){
			  return root;
		  }  
	  }
	  //if vertexName is not in Cache...
	  //check the cache date and use LRU to replace the GBlock
	  this.updateCache();

	  return findVertexInCache(vertexID);
  }
  public void updateCache(){
	  Iterator<Entry<String, GBlock>> cacheItr = map.entrySet().iterator();
	  Entry<String, GBlock> tempEntry;
	  int numOfupdate = 0; //control update block numbers
	  while(cacheItr.hasNext()){
		  // check which block should be replace and which block should be put in
		  tempEntry = cacheItr.next();
		  if(tempEntry.getValue().isExpired()){
			  numOfupdate = numOfupdate + 1;
			  //remove and shutdown the expired GBlock
			  map.remove(tempEntry.getValue()); 
			  tempEntry.getValue().shutdownGB();
			  //And set its partID to false in GraphPartSet
			  GraphPartSet.put(tempEntry.getKey(), false);
		  }
	  }
	  //which gblock should be update into cache?
	  
	  for(String PartID : GraphPartSet.keySet()){
		  if(!GraphPartSet.get(PartID) && (numOfupdate > 0)){
			  loadGraphToCache(PartID);
			  GraphPartSet.put(PartID, true);
			  numOfupdate = numOfupdate - 1;
		  }
	  }
	  
	  
  }
  public void loadGraphToCache(String BorderID){
	  String prefix = "/Volumes/MacintoshHDD/Users/arvin/Documents/neo4j-community-1.9.5/data/";
	  Map<String, String> config = new HashMap<String, String>();
		 config.put("online_backup_enabled", "false");
	  Neo4jGraph indexedGraph = new Neo4jGraph(prefix+"graph-"+BorderID+".db",config);
	  GBlock gBlock = new GBlock(indexedGraph,BorderID);
	  this.putCache(gBlock);
	  
  }
  public void putCache(Cacheable object)
  {
	  if (map.containsKey(object.getIdentifier())) {
	    /*just update*/
	  }
	  else {
		  if (map.size() > BLOCK_CACHE_SIZE) {
			  updateCache();
		  }
		  map.put(object.getIdentifier(), (GBlock)object);  
	  }
    
    
  }
  
  public void cleanCache() {
	  map.clear();
  }
  
  public Cacheable getCache(Object identifier)
  {
      Cacheable object = (Cacheable)map.get(identifier);
      if (object == null)
       return null;
      if (object.isExpired())
      {
        map.remove(identifier);
        return null;
      }
      else
      {
        return object;
      }
  }  
}
