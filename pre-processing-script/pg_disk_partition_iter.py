import sys
import json
import postgresql
import pdb

class Node:
    def __init__(self, nodeID, depth, subgraphID):
        self.nodeID = nodeID
        self.depth = depth
        self.subgraphID = subgraphID

class Partition:
    def __init__(self, depth):
        self.partID = 0
        self.depth = int(depth)
        self.partIDFornode = list()
        self.partIDList = list()
        self.targetList = list()
        self.expansion_queue = list()
        self.connect_db()
        self.update_valid_depth_part_parent_sql = self.db.prepare('update neighborMap set valid = $2, depth = $3, partID = $4, parent = $5 where nodeID = $1')
        self.get_node_info_sql = self.db.prepare('select nodeID, neighbor, valid, depth, partID, parent from neighborMap where nodeID = $1')
        self.get_border_sql = self.db.prepare('select borderID, neighbor, subgraphID from borderMap where borderID = $1')
        self.insert_border_sql = self.db.prepare('insert into borderMap values($1, $2, $3)')

    def connect_db(self):
        with open('db_setting.json') as db_file:
            db_setting = json.load(db_file)
        self.db = postgresql.open(user = db_setting['user'],
                                  password = db_setting['password'],
                                  host = db_setting['host'],
                                  database = db_setting['database'],
                                  port = db_setting['port'])

    def readTargetFile(self, targetFile):
        with open(targetFile, 'r') as myfile:
            for line in myfile:
                targetRow = line.strip().split('\t')
                self.targetList.append(targetRow[0])

    def add_node_to_dict(self, nodeID, depth, partID, parent):
        #add node to file
        if partID not in self.partIDFornode:
           self.partIDFornode.append(partID)
           f2 = open('../batch-import/ResearchRealData/mini_Real_new/mini_node/'+str(partID)+'_part.node', 'w', encoding='utf-8')
           f2.write('nodeID:string:Nodes\ttype\tcount\twalked\tLandMark\tsubgraphID'+'\n')
           f2.write(nodeID+'\t'+'1'+'\t'+'0'+'\t'+'0'+'\t'+'0'+'\t'+str(partID)+'\n')
           f2.close()
        else:
           f2 = open('../batch-import/ResearchRealData/mini_Real_new/mini_node/'+str(partID)+'_part.node', 'a', encoding='utf-8')
           f2.write(nodeID+'\t'+'0'+'\t'+'0'+'\t'+'0'+'\t'+'0'+'\t'+str(partID)+'\n')
           f2.close()
        with self.db.xact():
            self.update_valid_depth_part_parent_sql(nodeID, '1', depth, str(partID), parent)
    
    def add_edge_to_dict(self, nodeID, neighbor, partID):
        #add edge to file
        if partID not in self.partIDList:
            self.partIDList.append(partID) 
            f = open('../batch-import/ResearchRealData/mini_Real_new/mini_edge/'+str(partID)+'_part','w',encoding='utf-8')
            f.write('nodeID:string:Nodes\tnodeID:string:Nodes\tlabel\twalked\tweight\tcount\tsubgraphID'+'\n')
            f.write(nodeID+'\t'+neighbor+'\t'+'edge_label'+'\t'+'0'+'\t'+'1'+'\t'+'0'+'\t'+str(partID)+'\n')
            f.close()
        else:
            f = open('../batch-import/ResearchRealData/mini_Real_new/mini_edge/'+str(partID)+'_part','a',encoding='utf-8')
            f.write(nodeID+'\t'+neighbor+'\t'+'edge_label'+'\t'+'0'+'\t'+'1'+'\t'+'0'+'\t'+str(partID)+'\n')
            f.close()

    def get_node_information(self, nodeID):
        with self.db.xact():
            info_result = self.get_node_info_sql(nodeID)
        return {'nodeid': info_result[0][0],
                'neighbors': info_result[0][1],
                'valid': info_result[0][2],
                'depth': info_result[0][3],
                'partid': info_result[0][4],
                'parent': info_result[0][5]}

    def insert_border(self, node_info, neighbor_info):
        if node_info['partid'] == neighbor_info['partid']:
            #if node & neighbor in same part, then skip
            return

        if node_info['nodeid'] == neighbor_info['parent']:
            #if node is neighbor's parent, then skip
            return

        with self.db.xact():
            is_border_node = self.get_border_sql(node_info['nodeid'])
            is_border_neighbor = self.get_border_sql(neighbor_info['nodeid'])
        if is_border_node:
            pass
        else:
            with self.db.xact():
                self.insert_border_sql(node_info['nodeid'], node_info['neighbors'], node_info['partid'])

        if is_border_neighbor:
            pass
        else:
            with self.db.xact():
                self.insert_border_sql(neighbor_info['nodeid'], neighbor_info['neighbors'], neighbor_info['partid'])

    def run(self, targetFile):
        self.readTargetFile(targetFile)

        for target_node in self.targetList:
            self.add_node_to_dict(target_node, 0, str(self.partID), '-1')
            self.expansion_queue.append(target_node)
            self.partID += 1

        while True:
            if not self.expansion_queue:
                break

            nodeID = self.expansion_queue[0]
            node_info = self.get_node_information(nodeID)
            for neighbor in node_info['neighbors'].split(','):
                neighbor_info = self.get_node_information(neighbor)
                is_partition = neighbor_info['valid']
                if int(is_partition):
                    self.insert_border(node_info, neighbor_info)
                    continue

                if node_info['depth'] >= self.depth:
                    continue
                self.add_node_to_dict(neighbor, node_info['depth']+1, str(node_info['partid']), node_info['nodeid'])
                self.add_edge_to_dict(nodeID, neighbor, node_info['partid'])
                self.expansion_queue.append(neighbor)
            self.expansion_queue.remove(nodeID)

    def print_result(self):
        print ('id\tdepth\tsubgraph\tparent')
        get_all_node_sql = self.db.prepare('select nodeID, depth, partID, parent from neighborMap')
        with self.db.xact():
            all_node = get_all_node_sql()
        for node_info in all_node:
            print (node_info[0] + '\t' + str(node_info[1]) + '\t' + node_info[2] + '\t' + node_info[3])

        print ('\n---border---')
        print ('id\tsubgraph')
        get_all_border_sql = self.db.prepare('select borderID, subgraphID from borderMap')
        with self.db.xact():
            all_border = get_all_border_sql()
        for border_info in all_border:
            print (border_info[0] + '\t' + border_info[1])
        self.db.close()

if __name__ == '__main__':
    targetFile = sys.argv[1]
    depth = sys.argv[2]
    partition = Partition(depth)
    partition.run(targetFile)
    #partition.print_result()
