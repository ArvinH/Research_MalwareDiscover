package netdb.graph.alg;

import java.io.FileInputStream;
import java.io.IOException;
import java.util.Calendar;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Properties;
import java.util.TreeMap;

import netdb.graph.opts.framework.GBlock;
import netdb.graph.opts.framework.OptsExperimentSet;
import netdb.graph.unit.CacheManager;

import com.tinkerpop.blueprints.Direction;
import com.tinkerpop.blueprints.Edge;
import com.tinkerpop.blueprints.Vertex;
import com.tinkerpop.blueprints.impls.neo4j.Neo4jGraph;
import com.tinkerpop.blueprints.oupls.jung.GraphJung;

import edu.uci.ics.jung.algorithms.shortestpath.DijkstraShortestPath;




public class ShortestPath {
	private CacheManager blockCache = null;
	private TargetMonitor targetMonitor = null;
	public ShortestPath(){
		
		Properties prop = new Properties();
    	try {
          prop.load(new FileInputStream("/Volumes/MacintoshHDD/Users/arvin/git/Research_MalwareDiscover/src/main/java/netdb/graph/properties/config.properties"));
          
          String[] targetList = prop.getProperty("TARGET_VERTEXID").split(",");
          OptsExperimentSet.TARGET_LIST = targetList;
          String[] GraphPartIDListString = prop.getProperty("GRAPH_PARTID").split(",");
          OptsExperimentSet.GRAPH_PARTID = GraphPartIDListString;
    	} catch (IOException e) {
    		e.printStackTrace();
    	}	
    	
    	this.blockCache = new CacheManager();
    	this.targetMonitor = new TargetMonitor(this.blockCache);
	}
	/**
	 * 
	 * @param queryNode
	 * @param targetNode
	 * @param K for query times
	 */
	public void run(HashMap<String,String> queryNode, LinkedList<String> targetNode, int K){ 
		Iterator<String> queryItr = queryNode.keySet().iterator();
		String rootKey = null;
		String[] rootV = null;
		Vertex root = null;
		Vertex target = null;
		GBlock gblock = null;
		List<Edge> spResult = null;
		TreeMap<Integer, Vertex> lengthMap = new TreeMap<Integer, Vertex>();
		HashSet<Vertex> finalResult = new HashSet<Vertex>();
		while(queryItr.hasNext()){
			rootKey = queryItr.next();
			rootV = queryNode.get(rootKey).split("_");
			root = this.blockCache.findVertexInCache(rootV[0]);
			for(String targetV : targetNode){
				target = this.blockCache.findVertexInCache(targetV);
				gblock = (GBlock)this.blockCache.getCache("single-L");
				GraphJung<Neo4jGraph> gj = new GraphJung<Neo4jGraph>(gblock.getGraph());
				DijkstraShortestPath<Vertex, Edge> dsp = new DijkstraShortestPath<Vertex, Edge>(gj);
				spResult = dsp.getPath(root, target);
				//compare length
				lengthMap.put(spResult.size(), spResult.get(spResult.size()-1).getVertex(Direction.IN));
			}
			Iterator<Integer> spRptr = lengthMap.keySet().iterator();
			int counter = K;
			int targetPathLength;
			while(spRptr.hasNext() && counter > 0){
				targetPathLength = spRptr.next();
				finalResult.add(lengthMap.get(targetPathLength));
				counter = counter - 1;
			}
			
			
		}
		
		for(Vertex v : finalResult){
			for(int length : lengthMap.keySet()){
				if(lengthMap.get(length).getProperty("nodeID").equals(v.getProperty("nodeID"))){
					System.out.println("target found: "+v.getProperty("nodeID")+" length = "+length);
				}
			}
		}
		
	}
	public void targetMonitor(){
		this.targetMonitor.monitor();
	}
	public static void main(String[] agrs) {
		ShortestPath sp = new ShortestPath();
		HashMap<String,String> queryNodeList = new HashMap<String,String>();
		LinkedList<String> targetNodeList = new LinkedList<String>();
		for(String target : OptsExperimentSet.TARGET_LIST){
			targetNodeList.add(target);
		}
		
		
		queryNodeList.put("1","938_2014-01-21 09:54:26");
		queryNodeList.put("2","938_2014-01-21 10:54:26");
		queryNodeList.put("3","813_2014-01-21 09:30:26");
		queryNodeList.put("4","813_2014-01-21 13:20:26");
		Date startTime = Calendar.getInstance().getTime();
		sp.run(queryNodeList,targetNodeList,3);
		Date currentTime = Calendar.getInstance().getTime();
		long diff = (currentTime.getTime() - startTime.getTime()) / 1000;
		System.out.println("Total time: "+diff);
		
		//show all target's status
		sp.targetMonitor();
	}
	

}
