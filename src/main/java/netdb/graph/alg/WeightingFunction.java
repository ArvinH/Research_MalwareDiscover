package netdb.graph.alg;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.Iterator;
import java.util.TreeMap;

import netdb.graph.opts.framework.Walker;

import com.tinkerpop.blueprints.Direction;
import com.tinkerpop.blueprints.Edge;
import com.tinkerpop.blueprints.Vertex;

public class WeightingFunction {
	SimpleDateFormat simpleDateFormat;
	static long slidingWindowSize;

	public WeightingFunction(long slidingWindowSize){
		this.simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'");
		WeightingFunction.slidingWindowSize = slidingWindowSize;
	}
	//update weight for all edges on path to Target
	//according to sliding window(time)
	public void update(Walker walker){
		//should get all path(have target)
		TreeMap<Integer, ArrayList<Edge>> allPath = walker.getAllPath();
		int totalNumOfwalk = allPath.size();
		Vertex edgeInV;
		Vertex edgeOutV;
		for(int key : allPath.keySet()){	
			ArrayList<Edge> pathToTarget = allPath.get(key);
			edgeInV = pathToTarget.get(pathToTarget.size()-1).getVertex(Direction.IN);
			edgeOutV = pathToTarget.get(pathToTarget.size()-1).getVertex(Direction.OUT);
			if("1".equals((String)edgeInV.getProperty("type")) || "1".equals((String)edgeOutV.getProperty("type"))){
				Iterator<Edge> edgeptr = pathToTarget.iterator();
				Edge tempEdge;
				String timeStamp;
				ArrayList<String> counting;
				long diff;
				int indexOfcountingString;
				double newWeight;
				while(edgeptr.hasNext()){
					tempEdge = edgeptr.next();
					//if edge is attached, don't need to be update
					if(!"attachedTarget".equals((String)tempEdge.getLabel())){
						counting = tempEdge.getProperty("count");
						timeStamp = walker.getQueryTime();
							try {
								Date currentTime = this.simpleDateFormat.parse(timeStamp);
								Date previousTime;
								
								// +=2, because the array would be ['time',count,'time2',count2,...]
								for(indexOfcountingString = 0; indexOfcountingString < counting.size(); indexOfcountingString+=2){
									if(counting.get(indexOfcountingString).contains("_")){
										//timestamp
										previousTime = this.simpleDateFormat.parse(counting.get(indexOfcountingString));
										//diff Minutes
										diff = (currentTime.getTime() - previousTime.getTime()) / (60 * 1000);
										if(diff < WeightingFunction.slidingWindowSize){
											//do nothing, skip to next counting
										}
										else{
											// calculate the new weight
											newWeight = calculateNewWeight(pathToTarget.size(), pathToTarget.indexOf(tempEdge), Double.valueOf(counting.get(counting.size()-1)), Double.valueOf(counting.get(indexOfcountingString+1)));
											tempEdge.setProperty("weight", newWeight);
										}
									}
								}
							} catch (ParseException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
					}
				}
			}
			
			
		}
		
	}
	
	private static double calculateNewWeight(int edgeLength, int indexInEdge, double avg_currentCount, double avg_previousCount){
		
		double x = avg_currentCount - avg_previousCount;
		double y;
		double factor;
		y = 5*(x/(4+x));
		factor = indexInEdge/edgeLength;
		y = (y+1)+factor;
		return y;

	}
	
	
	//for boundary ## Deprecated!!
	public static void updateWeight(Edge edge, ArrayList<?> pathToTarget){
		SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyyMMdd_HHmmss");
		String timeStamp;
		ArrayList<String> counting;
		counting = edge.getProperty("count");
		timeStamp = simpleDateFormat.format(Calendar.getInstance().getTime());
		long diff;
		int indexOfcountingString;
		double newWeight;
			Date currentTime;
			try {
				currentTime = simpleDateFormat.parse(timeStamp);
				Date previousTime;
				
				// +=2, because the array would be ['time',count,'time2',count2,...]
				for(indexOfcountingString = 0; indexOfcountingString < counting.size(); indexOfcountingString+=2){
					if(counting.get(indexOfcountingString).contains("_")){
						//timestamp
						previousTime = simpleDateFormat.parse(counting.get(indexOfcountingString));
						//diff Minutes
						diff = (currentTime.getTime() - previousTime.getTime()) / (60 * 1000) % 60;
						if(diff < WeightingFunction.slidingWindowSize){
							//do nothing, skip to next counting
						}
						else{
							// calculate the new weight
								newWeight = calculateNewWeight(pathToTarget.size(), pathToTarget.indexOf(edge), Integer.valueOf(counting.get(counting.size()-1)), Integer.valueOf(counting.get(indexOfcountingString+1)));
								edge.setProperty("weight", newWeight);
						}
					}
				}
			} catch (ParseException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		
	}
	

}