package netdb.graph.alg;

import java.util.Date;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Iterator;

import netdb.graph.opts.framework.OptsExperimentSet;
import netdb.graph.opts.framework.Walker;

import com.tinkerpop.blueprints.Edge;
import com.tinkerpop.blueprints.Vertex;
/**
 * 
 * @author arvin
 * first:
 * this visitor is used to insert all visited Vertex and edges into walker, 
 * and also used to update the weight on the whole path that walker pass by.
 * 
 * Second:
 * check the vertex it visited is target or not
 */
public class AccumulateVisitor implements IGraphSearchVisitor {
    private boolean targetOrNot;
    private String TargetType;
    private WeightingFunction weightingFunction;
    private long slidingWindowSize;
    private SimpleDateFormat simpleDateFormat;
    
    /**
     * 
     * @param targetList: List of target
     * @param threshold: threshold for BoundaryProcessor
     * @param slidingWindowSize: sliding window gap(minutes)
     */
    public AccumulateVisitor(String TargetType, long slidingWindowSize){
    	this.TargetType = TargetType;
    	this.targetOrNot = false;
    	this.slidingWindowSize = slidingWindowSize;
    	this.weightingFunction = new WeightingFunction(this.slidingWindowSize);
    	this.simpleDateFormat = new SimpleDateFormat("yyyyMMdd_HHmmss");
    }
    /**
     * visit vertex and Accumulate
     */
	public boolean visitVertex(Vertex v,Edge impactedEdge, Walker walker){
		/**
		 * check the v is the target or not
		 */
		int count = 0;
		ArrayList<String> counting;
		String timeStamp = null;
		this.targetOrNot = targetCompare(v,this.TargetType);
		//if v is not root
		if(impactedEdge != null && !"attachedTarget".equals((String)impactedEdge.getLabel())){
			walker.addNode(v,this.targetOrNot);
			

			if(Integer.parseInt((String) impactedEdge.getProperty("count")) == 0){
				count = 1; 
				timeStamp = this.simpleDateFormat.format(Calendar.getInstance().getTime());
				ArrayList<String> newcounting = new ArrayList<String>();
				newcounting.add(timeStamp);
				newcounting.add(String.valueOf(count));
				impactedEdge.setProperty("count",newcounting);
				walker.addEdge(impactedEdge,this.targetOrNot);
			}
			else{
				counting = impactedEdge.getProperty("count"); 
				count = Integer.parseInt(counting.get(counting.size()-1));
				timeStamp= new SimpleDateFormat("yyyyMMdd_HHmmss").format(Calendar.getInstance().getTime());
				counting.add(timeStamp);
				counting.add(String.valueOf(count+1));
				impactedEdge.setProperty("count",counting);
				walker.addEdge(impactedEdge,this.targetOrNot);
				
			}
			

		}// if v is root
		else if (impactedEdge == null){
			walker.addNode(v,this.targetOrNot);
		}
		
		
			return this.targetOrNot;
	}
	
	public void pathWeightUpdate(Walker walker){
    		this.weightingFunction.update(walker);
	}
	
	public void setTargetOrNotFlag(boolean flag){
		this.targetOrNot = flag;
	}
	
	public boolean targetCompare(Vertex v, String TargetType){
	  	boolean compareResult = false;
	  	int targetCount;
	  		if (TargetType.equals(v.getProperty("type"))){
	  			compareResult = true;
	  			targetCount = Integer.parseInt((String)v.getProperty("count"));
	  			v.setProperty("count", String.valueOf(targetCount+1));
	  		}
	  	
	  return compareResult; 
  }
	


}
