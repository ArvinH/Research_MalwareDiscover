package netdb.graph.opts.framework;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.TreeMap;

import netdb.database.opt.DatabaseOpts;
import netdb.graph.alg.IGraphSearchStrategy;
import netdb.graph.alg.TargetMonitor;
import netdb.graph.unit.CacheManager;

import com.tinkerpop.blueprints.Vertex;

/**
 * 
 * @author arvin
 * Record the Graphs which are loaded in memory
 */
public class IndexedGraph {
  private CacheManager blockCache = null;
  private Vertex root=null;
  private ArrayList<Walker> queryResult;
  
  public IndexedGraph( ){
	 this.blockCache = new CacheManager();
	 queryResult = new ArrayList<Walker>();
  }
  public HashSet<Vertex> query(IGraphSearchStrategy queryStrategy, TreeMap<Integer, String> queryNodeList) {
	  TargetMonitor targetMonitor = new TargetMonitor(this.blockCache);
	  ArrayList<Walker> walkerList = new ArrayList<Walker>();
	  Walker walker = null;
	  for(int i=0;i < queryNodeList.size(); i++ ){
		  walker = new Walker();
		  walkerList.add(walker);
	  }
	  Iterator<Integer> queryIterator = queryNodeList.keySet().iterator();
	  Iterator<Walker> walkerIterator = walkerList.iterator();
	  //set blockCache for queryStrategey
	  queryStrategy.setCache(this.blockCache);
	  //find all query result
	  String[] currentQueryNodeContent = null;
	 
	  while(queryIterator.hasNext() && walkerIterator.hasNext()){
		  //find vertex from GBlock cache
		  currentQueryNodeContent = queryNodeList.get(queryIterator.next()).split("_");
		  root = blockCache.findVertexInCache(currentQueryNodeContent[0]);
		  if(root == null){
			  // can't find the query node
			  //skip
		  }
		  else{
			  System.out.println(currentQueryNodeContent[0]);
			  walker = walkerIterator.next();
			  walker.setQueryTerm(currentQueryNodeContent[0]);
			  walker.setQueryTime(currentQueryNodeContent[1]);
			  queryResult.add(queryStrategy.query(root, walker));
			  walker.printEachQueryTargetCount();
		  }
	  } 
	  
	  // (for MKNN search)
	  //then compare the intersection of all queryResult
		Iterator<Walker> queryResult_itr = queryResult.iterator();
		HashSet<Vertex> targetSet = new HashSet<Vertex>();
		while(queryResult_itr.hasNext()){
			targetSet.addAll(queryResult_itr.next().getFoundTargets());
		}
		//print all target activity status
		targetMonitor.monitor();

	  
	  return targetSet;
  }
  public void CleanCache(){
	  this.blockCache.cleanCache();
  }
  
}
