package netdb.graph.alg;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Random;
import java.util.Set;

import com.tinkerpop.blueprints.Edge;

public class RandomProb {
	HashMap<Edge, Double> edgeProb;
	public RandomProb(){
		edgeProb = new HashMap<Edge, Double>();
	}
	public Edge calculate(double sumOfweightingValue, HashMap<Edge, Double> weight){
		Random r = new Random();
		LinkedHashMap<Edge, Double> sortedWeight = RandomProb.sortByComparator(weight);
		double randomValue = 0 + (sumOfweightingValue - 0) * r.nextDouble();
		Edge tempEdge;
		Iterator<Edge> edgePtr = sortedWeight.keySet().iterator();
		double start = 0, end;
		while(edgePtr.hasNext()){
			tempEdge = edgePtr.next();
			end = start + weight.get(tempEdge);
			if(start< randomValue && randomValue < end){
				return tempEdge;
			}
			start = end;
		}
		return null;
	}
	public double probToTarget(double sumOfweightingValue, Edge targetEdge){
		double targetWeight = Double.parseDouble((String)targetEdge.getProperty("weight"));
		
		return (targetWeight/sumOfweightingValue);
	}
	
	private static LinkedHashMap<Edge, Double> sortByComparator(HashMap<Edge, Double> unsortMap) {
		 
		Set<Entry<Edge, Double>> set = unsortMap.entrySet();
        List<Entry<Edge, Double>> list = new ArrayList<Entry<Edge, Double>>(set);
        Collections.sort( list, new Comparator<Map.Entry<Edge, Double>>()
        {
            public int compare( Map.Entry<Edge, Double> o1, Map.Entry<Edge, Double> o2 )
            {
                return (o1.getValue()).compareTo( o2.getValue() );
            }
        } );
        LinkedHashMap<Edge, Double> sortedMap = new LinkedHashMap<Edge, Double>();
        for(Map.Entry<Edge, Double> entry:list){
        	sortedMap.put(entry.getKey(), entry.getValue());
        }
		return sortedMap;
	}
}
