package netdb.graph.alg;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.HashMap;
import java.util.Iterator;

import netdb.graph.opts.framework.Walker;

import com.tinkerpop.blueprints.Edge;
import com.tinkerpop.blueprints.Vertex;
/**
 * 
 * @author arvin
 * first:
 * this visitor is used to insert all visited Vertex and edges into walker, 
 * and also used to update the weight on the whole path that walker pass by.
 * 
 * Second:
 * check the vertex it visited is target or not
 */
public class AccumateVisitor implements IGraphSearchVisitor {
    private boolean targetOrNot;
    private ArrayList<Vertex> targetList;
    private WeightingFunction weightingFunction;
    private BoundaryProcessor boundaryProcessor;
    
    /**
     * 
     * @param targetList: List of target
     * @param threshold: threshold for BoundaryProcessor
     */
    public AccumateVisitor(ArrayList<Vertex> targetList, double threshold){
    	this.targetList = targetList;
    	this.targetOrNot = false;
    	this.weightingFunction = new WeightingFunction();
    	this.boundaryProcessor = new BoundaryProcessor(threshold);
    }
    
	public boolean visitVertex(Vertex v,Edge impactedEdge, Walker walker) {
		/**
		 * check the v is the target or not
		 */
		this.targetOrNot = targetCompare(v,this.targetList);
		//if v is not root
		if(impactedEdge != null){
			walker.addNode(v,this.targetOrNot);
			@SuppressWarnings("unchecked")
			int count = ((HashMap<String,Integer>)impactedEdge.getProperty("count")).get("timeStamp");
			String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(Calendar.getInstance().getTime());
			HashMap<String,Integer> counting = new HashMap<String,Integer>();
			counting.put(timeStamp, count);
			impactedEdge.setProperty("count",counting);
			walker.addEdge(impactedEdge,this.targetOrNot);

		}// if v is root
		else if (impactedEdge == null){
			walker.addNode(v,this.targetOrNot);
		}
		
		//if found target, update the whole path
		if(this.targetOrNot){
			pathWeightUpdate(walker);
		}
			return this.targetOrNot;
	}
	
	public void pathWeightUpdate(Walker walker){
    		WeightingFunction weightingFunction = new WeightingFunction();
			weightingFunction.update(walker);
	}
	
	public void setTargetOrNotFlag(boolean flag){
		this.targetOrNot = flag;
	}
	
	//need to be modify
	public boolean targetCompare(Vertex v, ArrayList<Vertex> t){
	  	boolean compareResult = false;
	  	Iterator<Vertex> targetPtr = t.iterator();
	  	while(targetPtr.hasNext()){
	  		String targetType = (String)targetPtr.next().getProperty("type");
	  		if (targetType.equals(v.getProperty("type"))){
	  			compareResult = true;
	  		}
	  	} 	
	  	
	  return compareResult; 
  }
	


}
