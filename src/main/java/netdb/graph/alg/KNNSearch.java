package netdb.graph.alg;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.TreeSet;

import netdb.database.opt.DatabaseOpts;
import netdb.graph.opts.framework.OptsExperimentSet;
import netdb.graph.opts.framework.Walker;
import netdb.graph.unit.CacheManager;

import com.tinkerpop.blueprints.Direction;
import com.tinkerpop.blueprints.Edge;
import com.tinkerpop.blueprints.Vertex;

/**
 * 
 * @author arvin KNN Search Strategy
 */
public class KNNSearch implements IGraphSearchStrategy {
	private HashSet<Vertex> knnCandidate;
	private IGraphSearchVisitor Ivisitor;
	private ArrayList<Edge> EdgeList;
	private CacheManager blcokCache;
	private RandomProb RProb;
	private boolean foundTargetOrNot = false;
	private int Stepsthreshold = 0;
	private int K;
	private boolean skipOrNot;
	private Vertex returnVertex;
	private SimpleDateFormat simpleDateFormat;

	public KNNSearch(int Stepsthreshold, int k, double boundaryThreshold) {
		knnCandidate = new HashSet<Vertex>();
		this.Stepsthreshold = Stepsthreshold;
		EdgeList = new ArrayList<Edge>();
		RProb = new RandomProb();
		this.K = k;
		skipOrNot = false;
		this.simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
	}

	@Override
	public Walker query(Vertex vertex, Walker walker) {
		Vertex root = vertex;
		Edge preEdge = null;
		//System.out.println("root node : " + root.getProperty("nodeID"));

		int stepsCounter = 0;
		int pathCounter = 0;
		while ((pathCounter < this.K)) {
			vertex = root;
			setAdjVertexAndEdges(vertex);
			// for root
			foundTargetOrNot = Ivisitor.visitVertex(vertex, null, walker);

			while (!this.foundTargetOrNot && stepsCounter < this.Stepsthreshold) {
				vertex = getNextVisitVertex(vertex, walker);
				if (vertex == null) {
					walker.setNewPath();
					break;
				} else {
					setAdjVertexAndEdges(vertex);
					stepsCounter = stepsCounter + 1;
				}
				if (stepsCounter >= this.Stepsthreshold) {
					//System.out.println("Steps out of threshold");
					if (!this.foundTargetOrNot) {
						walker.setNewPath();
					}
				}
			}
			pathCounter = pathCounter + 1;
			this.foundTargetOrNot = false;
			stepsCounter = 0;
			walker.cleanEdgeWalkedLable(); // clean walked edge to 0
		}
		Ivisitor.pathWeightUpdate(walker);
		return walker;
	}

	/**
	 * calculate the probability of walking to or not walking to v's neighbors
	 * and return the neighbor which should be walked
	 */
	public Vertex getNextVisitVertex(Vertex lastV, Walker walker) {
		long diff;// for valid time
		String bordertargetID = null;
		Vertex borderTarget = null;
		if (EdgeList.size() != 0) {
			// EdgeList = walker.getEdgeList();
			Iterator<Edge> checkAttachedTarget;
			Iterator<Edge> edgePtr = EdgeList.iterator();
			Edge e = null;

			// find the most prob to walk
			HashMap<Edge, Double> weightMap = new HashMap<Edge, Double>();
			double sumOfweightingValue = 0;
			double edgeWeight;
			while (edgePtr.hasNext()) {
				e = edgePtr.next();
				edgeWeight = Double.parseDouble((String) e
						.getProperty("weight"));
				sumOfweightingValue = sumOfweightingValue + edgeWeight;
				weightMap.put(e, edgeWeight);
				// here to decide which edge should be walked
			}
			e = RProb.calculate(sumOfweightingValue, weightMap);
			e.setProperty("walked", "1");
			Vertex vIn = e.getVertex(Direction.IN);
			Vertex vOut = e.getVertex(Direction.OUT);
			if (lastV.equals(vIn)) {
				foundTargetOrNot = Ivisitor.visitVertex(vOut, e, walker);
				bordertargetID = Ivisitor.checkBorderTarget(vOut);
				if (bordertargetID != null) {
					borderTarget = this.blcokCache
							.findVertexInCache(bordertargetID);
					Edge newEdge = vOut.addEdge("attachedBorderTarget",
							borderTarget);
					newEdge.setProperty("count", "0");
					newEdge.setProperty("walked", "1");
					newEdge.setProperty("weight", "1");
					newEdge.setProperty("subgraphID", "single");

					foundTargetOrNot = Ivisitor.visitVertex(borderTarget,
							newEdge, walker);
				}

				vOut.setProperty("walked", "1");
				// check if meet valid border
				if ("1".equals((String) vOut.getProperty("valid"))
						&& "yes".equals((String) vOut.getProperty("border"))) {
					checkAttachedTarget = vOut.getEdges(Direction.OUT,
							"attachedTarget").iterator();
					while (checkAttachedTarget.hasNext()) {
						Edge attachedTargetedge = checkAttachedTarget.next();
						Vertex attachedTarget = attachedTargetedge
								.getVertex(Direction.OUT);
						// add shortcut target into knnCandidate
						knnCandidate.add(attachedTarget);
						// visit attached target (add to this path)
						foundTargetOrNot = Ivisitor.visitVertex(attachedTarget,
								attachedTargetedge, walker);
						// check the border is valid or not for now
						try {
							Date validTime = this.simpleDateFormat
									.parse((String) vOut
											.getProperty("validTime"));
							Date currentTime = this.simpleDateFormat
									.parse(walker.getQueryTime());
							// diff can be adjusted depends on datasets;
							diff = (currentTime.getTime() - validTime.getTime())
									/ (60 * 1000);
							if (diff > 100) {
								vOut.setProperty("valid", "0");

								attachedTargetedge.remove();
							} else {
								// keep going
							}

						} catch (ParseException e1) {
							// TODO Auto-generated catch block
							e1.printStackTrace();
						}

					}
				}
				returnVertex = vOut;

			} else if (lastV.equals(vOut)) {
				foundTargetOrNot = Ivisitor.visitVertex(vIn, e, walker);
				bordertargetID = Ivisitor.checkBorderTarget(vIn);
				if (bordertargetID != null) {
					borderTarget = this.blcokCache
							.findVertexInCache(bordertargetID);
					Edge newEdge = vIn.addEdge("attachedBorderTarget",
							borderTarget);
					newEdge.setProperty("count", "0");
					newEdge.setProperty("walked", "1");
					newEdge.setProperty("weight", "1");
					newEdge.setProperty("subgraphID", "single");
					foundTargetOrNot = Ivisitor.visitVertex(borderTarget,
							newEdge, walker);
				}
				vIn.setProperty("walked", "1");
				if ("1".equals((String) vIn.getProperty("valid"))
						&& "yes".equals((String) vIn.getProperty("border"))) {
					checkAttachedTarget = vIn.getEdges(Direction.OUT,
							"attachedTarget").iterator();
					while (checkAttachedTarget.hasNext()) {
						Edge attachedTargetedge = checkAttachedTarget.next();
						Vertex attachedTarget = attachedTargetedge
								.getVertex(Direction.OUT);
						// add shortcut target into knnCandidate
						knnCandidate.add(attachedTarget);
						// visit attached target (add to this path)
						foundTargetOrNot = Ivisitor.visitVertex(attachedTarget,
								attachedTargetedge, walker);
						// check the border is valid or not for now
						try {
							Date validTime = this.simpleDateFormat
									.parse((String) vOut
											.getProperty("validTime"));
							Date currentTime = this.simpleDateFormat
									.parse(walker.getQueryTime());
							// diff can be adjusted depends on datasets;
							diff = (currentTime.getTime() - validTime.getTime())
									/ (60 * 1000);
							if (diff > 100) {
								vIn.setProperty("valid", "0");
								attachedTargetedge.remove();
							} else {
								// keep going
							}

						} catch (ParseException e1) {
							// TODO Auto-generated catch block
							e1.printStackTrace();
						}

					}
				}
				returnVertex = vIn;

			}

			// check if visitor found the target or not, then keep finding(go
			// back to find)
			// skipOrNot to control the found Target is found by skip or not
			if (foundTargetOrNot) {

				knnCandidate.add(walker.getLeastNode(foundTargetOrNot));

				return walker.getRoot(foundTargetOrNot);
			} else if (!foundTargetOrNot && !skipOrNot) {
				// keep finding
				return returnVertex;
			}
		} else if (EdgeList.size() == 0) {
			// change graph!
			String subgraphID = lastV.getProperty("subgraphID");
			String nodeID = lastV.getProperty("nodeID");
			// String graphPartNeedLoad = "single-L-forRW";
			// String graphPartNeedLoad = "single-L";
			// String graphPartNeedLoad = "RealSingle";
			// String graphPartNeedLoad = "RealSingle-newWeight";
			// String graphPartNeedLoad = "RealSingle-newWeightFunc";
			if ("-1".equals(subgraphID)) {
				// not border, can't connect to other graph
			} else {
				// check the borderMap table in mysql... find out which subgraph
				// is connected by it.

				DatabaseOpts databaseOpts = new DatabaseOpts(OptsExperimentSet.DatabaseURL,
						OptsExperimentSet.DatabaseName, OptsExperimentSet.DatabaseUserName, OptsExperimentSet.DatabasePwd);
				String graphPartNeedLoad = databaseOpts.checkBorderMap(nodeID,
						subgraphID);

				if ("-1".equals(graphPartNeedLoad)) {
					returnVertex = null;
				} else {
					
					if (!this.blcokCache.inCacheOrNot(graphPartNeedLoad)) {
						this.blcokCache.loadGraphToCache(graphPartNeedLoad);
					}
					
					// set border property for walker
					lastV.setProperty("border", "yes");
					

					returnVertex = this.blcokCache.findVertexInOtherGraph(
							nodeID, graphPartNeedLoad);
				}

			}

			
			return returnVertex;

		}

		return null;
	}

	public int getStepsThreshold() {
		return this.Stepsthreshold;
	}

	public void accept(IGraphSearchVisitor vis) {
		this.Ivisitor = vis;

	}

	@Override
	public void setCache(CacheManager blockCache) {
		this.blcokCache = blockCache;
	}

	@Override
	public boolean successOrNot() {
		// TODO Auto-generated method stub
		if (knnCandidate.size() == this.K) {
			return true;
		} else {
			return false;
		}
	}

	private void setAdjVertexAndEdges(Vertex lastV) {
		// first clean all elements in previous list
		EdgeList.clear();
		// collect all adjacent edges
		Iterator<Edge> edgeItr = lastV.getEdges(Direction.BOTH, "edge_label")
				.iterator();
		Edge adjEdge;
		while (edgeItr.hasNext()) {
			adjEdge = edgeItr.next();
			if ("0".equals(adjEdge.getProperty("walked"))) {
				EdgeList.add(adjEdge);
			}
		}

	}

}
