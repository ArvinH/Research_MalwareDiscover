package netdb.graph.opts.framework;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.TreeMap;

import com.tinkerpop.blueprints.Edge;
import com.tinkerpop.blueprints.Vertex;
/**
 * 
 * @author arvin
 * Walker : record all nodes and edges it walks by.
 */
public class Walker {
  private ArrayList<Vertex> visitedNodes;
  private TreeMap<Integer, ArrayList<Vertex>> foundPathvertex;
  private TreeMap<Integer, ArrayList<Edge>> foundPathedge;
  private ArrayList<Edge> visitedEdges;
  private int nth_path_node;
  private int nth_path_edge;
  private ArrayList<Vertex> targetList;
  private SimpleDateFormat simpleDateFormat;
  public Walker() {
	  this.visitedNodes = new ArrayList<Vertex>();
	  this.visitedEdges = new ArrayList<Edge>();
	  this.foundPathvertex = new TreeMap<Integer, ArrayList<Vertex>>();
	  this.foundPathedge = new TreeMap<Integer, ArrayList<Edge>>();
	  this.nth_path_node = 0;
	  this.nth_path_edge = 0;
	  this.simpleDateFormat = new SimpleDateFormat("yyyyMMdd_HHmmss");
	  this.targetList = new ArrayList<Vertex>();
  }
  
  public void addNode(Vertex v, boolean foundTargetOrNot) {
	  if(foundTargetOrNot){
		  //record new path
		  this.visitedNodes.add(v);
		  this.foundPathvertex.put(this.nth_path_node, this.visitedNodes);
		  this.nth_path_node = this.nth_path_node + 1;
		  this.visitedNodes = new ArrayList<Vertex>();
	  }
	  else if(!foundTargetOrNot){
		  this.visitedNodes.add(v);
		  this.foundPathvertex.put(this.nth_path_node, this.visitedNodes);
	  }
  }
  
  public void addEdge(Edge e, boolean foundTargetOrNot) {
	  if(foundTargetOrNot){
		  //record new path
		  this.visitedEdges.add(e);
		  this.foundPathedge.put(this.nth_path_edge, this.visitedEdges);
		  this.nth_path_edge = this.nth_path_edge + 1;
		  this.visitedEdges = new ArrayList<Edge>();
	  }
	  else if(!foundTargetOrNot){
		  this.visitedEdges.add(e);
		  this.foundPathedge.put(this.nth_path_edge, this.visitedEdges);
	  }
	  
  }
  
  public Vertex getLeastNode(boolean foundTargetOrNot) {
	  if(foundTargetOrNot){
		  return this.foundPathvertex.get(this.nth_path_node-1).get(this.foundPathvertex.get(this.nth_path_node-1).size()-1);
	  }
	  return this.visitedNodes.get(this.visitedNodes.size()-1);
  }
  
  public Vertex getRoot(boolean foundTargetOrNot){
	  if(foundTargetOrNot){
		 return this.foundPathvertex.get(this.nth_path_node-1).get(0);
	  }
	  else{
		 return this.visitedNodes.get(0);
	  }
  }
  
  public ArrayList<Vertex> getFoundTargets(){
	  Vertex targetCandidate = null;
	  for(int i : this.foundPathvertex.keySet()){
		  targetCandidate = this.foundPathvertex.get(i).get(this.foundPathvertex.get(i).size()-1);
		  
		  if("1".equals(targetCandidate.getProperty("type"))){
			  this.printPath(i);
			  this.setBorderProbEdge(i,targetCandidate);
			  targetList.add(targetCandidate);
		  }
	  }
	  return targetList;
  }
  
  public void setBorderProbEdge(int i, Vertex targetV){
	  ArrayList<Vertex> vertexList = this.foundPathvertex.get(i);
	  Vertex tempV;
	  String timeStamp = null;
	 for(int index = vertexList.size()-1; index > 0; index++){
		  tempV = vertexList.get(index);
		  if("yes".equals((String)tempV.getProperty("border"))){
			  tempV.addEdge("attachedTarget", targetV);
			  timeStamp = this.simpleDateFormat.format(Calendar.getInstance().getTime());
			  tempV.setProperty("valid", "1");
			  tempV.setProperty("validTime", timeStamp);
			  break;
		  }
		  
	  }
	  
  }
  
  public void setNewPath(){
	  this.nth_path_node = this.nth_path_node + 1;
	  this.visitedNodes = new ArrayList<Vertex>();
	  this.nth_path_edge = this.nth_path_edge + 1;
	  this.visitedEdges = new ArrayList<Edge>();
  }

  
  public TreeMap<Integer, ArrayList<Edge>> getAllPath(){
	  //return ALL Path
	  return this.foundPathedge;
  }
  
  public ArrayList<Edge> getLastPath(){
	  //return last Path(all edge in the path)
	 return this.foundPathedge.get(this.foundPathedge.lastKey());
  }
  public ArrayList<Edge> getPath(int i){
	  //return ith Path(all edge in the path)
	 return this.foundPathedge.get(i);
  }

  public double getPathWeight() {
	  //not finished yet
	  double weight = 0;
	  Iterator<Edge> eptr = this.visitedEdges.iterator();
	  while(eptr.hasNext()){
		  weight += (double)eptr.next().getProperty("weight");
	  }
	  return weight;
  }
  
  private void printPath(int i){
		  for(int j = 0; j < this.foundPathvertex.get(i).size(); j++){
			  System.out.print(this.foundPathvertex.get(i).get(j).getProperty("nodeID"));
			  System.out.print(" ("+ this.foundPathvertex.get(i).get(j).getProperty("subgraphID")+")");
			  if(j != this.foundPathvertex.get(i).size()-1){
				  System.out.print(" -> ");		
			  }
		  }
		  System.out.println();
  }
  
  
}
