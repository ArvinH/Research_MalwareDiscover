package netdb.graph.alg;

import java.util.Date;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Iterator;

import netdb.graph.opts.framework.Walker;

import com.tinkerpop.blueprints.Edge;
import com.tinkerpop.blueprints.Vertex;
/**
 * 
 * @author arvin
 * first:
 * this visitor is used to insert all visited Vertex and edges into walker, 
 * and also used to update the weight on the whole path that walker pass by.
 * 
 * Second:
 * check the vertex it visited is target or not
 */
public class AccumulateVisitor implements IGraphSearchVisitor {
    private boolean targetOrNot;
    private ArrayList<Vertex> targetList;
    private WeightingFunction weightingFunction;
    private BoundaryProcessor boundaryProcessor;
    private long slidingWindowSize;
    private SimpleDateFormat simpleDateFormat;
    
    /**
     * 
     * @param targetList: List of target
     * @param threshold: threshold for BoundaryProcessor
     * @param slidingWindowSize: sliding window gap(minutes)
     */
    public AccumulateVisitor(ArrayList<Vertex> targetList, double threshold, long slidingWindowSize){
    	this.targetList = targetList;
    	this.targetOrNot = false;
    	this.slidingWindowSize = slidingWindowSize;
    	this.weightingFunction = new WeightingFunction(this.slidingWindowSize);
    	this.boundaryProcessor = new BoundaryProcessor(0.6);
    	this.simpleDateFormat = new SimpleDateFormat("yyyyMMdd_HHmmss");
    }
    /**
     * visit vertex and Accumulate
     */
	public boolean visitVertex(Vertex v,Edge impactedEdge, Walker walker){
		/**
		 * check the v is the target or not
		 */
		int count = 0;
		ArrayList<String> counting;
		String timeStamp = null;
		this.targetOrNot = targetCompare(v,this.targetList);
		//if v is not root
		if(impactedEdge != null){
			walker.addNode(v,this.targetOrNot);
			

			if((Integer)impactedEdge.getProperty("count") == 0){
				count = 0; 
				timeStamp = this.simpleDateFormat.format(Calendar.getInstance().getTime());
				ArrayList<String> newcounting = new ArrayList<String>();
				newcounting.add(timeStamp);
				newcounting.add(String.valueOf(count));
				impactedEdge.setProperty("count",newcounting);
				walker.addEdge(impactedEdge,this.targetOrNot);
			}
			else{
					counting = impactedEdge.getProperty("count"); 
					count = Integer.valueOf(counting.get(counting.size()-1));
					timeStamp= new SimpleDateFormat("yyyyMMdd_HHmmss").format(Calendar.getInstance().getTime());
					counting.add(timeStamp);
					counting.add(String.valueOf(count+1));
					impactedEdge.setProperty("count",counting);
					walker.addEdge(impactedEdge,this.targetOrNot);
				
			}
			

		}// if v is root
		else if (impactedEdge == null){
			walker.addNode(v,this.targetOrNot);
		}
		
		//if found target, update the whole path
		if(this.targetOrNot){
			pathWeightUpdate(walker);
		}
			return this.targetOrNot;
	}
	
	public void pathWeightUpdate(Walker walker){
    		WeightingFunction weightingFunction = new WeightingFunction(this.slidingWindowSize);
			weightingFunction.update(walker);
	}
	
	public void setTargetOrNotFlag(boolean flag){
		this.targetOrNot = flag;
	}
	
	//need to be modify
	public boolean targetCompare(Vertex v, ArrayList<Vertex> t){
	  	boolean compareResult = false;
	  	Iterator<Vertex> targetPtr = t.iterator();
	  	while(targetPtr.hasNext()){
	  		String targetType = (String)targetPtr.next().getProperty("type");
	  		if (targetType.equals(v.getProperty("type"))){
	  			compareResult = true;
	  		}
	  	} 	
	  	
	  return compareResult; 
  }
	


}
