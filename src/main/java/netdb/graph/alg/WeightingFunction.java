package netdb.graph.alg;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.Iterator;
import java.util.LinkedList;

import netdb.graph.opts.framework.Walker;

import com.tinkerpop.blueprints.Edge;

public class WeightingFunction {
	SimpleDateFormat simpleDateFormat;
	long slidingWindowSize;

	public WeightingFunction(long slidingWindowSize){
		this.simpleDateFormat = new SimpleDateFormat("yyyyMMdd_HHmmss");
		this.slidingWindowSize = slidingWindowSize;
	}
	//update weight for all edges on path to Target
	//according to sliding window(time)
	public void update(Walker walker){
		LinkedList<Edge> pathToTarget = walker.getLastPath();
		Iterator<Edge> edgeptr = pathToTarget.iterator();
		Edge tempEdge;
		String timeStamp;
		ArrayList<String> counting;
		while(edgeptr.hasNext()){
			tempEdge = edgeptr.next();
			counting = tempEdge.getProperty("count");
			timeStamp = this.simpleDateFormat.format(Calendar.getInstance().getTime());
				Date currentTime;
				try {
					currentTime = this.simpleDateFormat.parse(timeStamp);
					Date previousTime;
					long diff;
					int indexOfcountingString;
					// +=2, because the array would be ['time',count,'time2',count2,...]
					for(indexOfcountingString = 0; indexOfcountingString < counting.size(); indexOfcountingString+=2){
						if(counting.get(indexOfcountingString).contains("_")){
							//timestamp
							previousTime = this.simpleDateFormat.parse(counting.get(indexOfcountingString));
							//diff Minutes
							diff = (currentTime.getTime() - previousTime.getTime()) / (60 * 1000) % 60;
							if(diff <= this.slidingWindowSize){
								//do nothing, skip to next counting
							}
							else{
								// calculate the new weight
								calculateNewWeight(pathToTarget.size(), pathToTarget.indexOf(tempEdge), Integer.valueOf(counting.get(counting.size()-1)), Integer.valueOf(counting.get(indexOfcountingString+1)));
							}
						}
					}
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
		
		}
	}
	
	private double calculateNewWeight(int edgeLength, int indexInEdge, int currentCount, int previousCount){
		
		
		
		
		
		return 0.0;
	}
	
	
	

}


