package netdb.graph.alg;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.TreeSet;

import netdb.database.opt.DatabaseOpts;
import netdb.graph.opts.framework.Walker;
import netdb.graph.unit.CacheManager;

import com.tinkerpop.blueprints.Direction;
import com.tinkerpop.blueprints.Edge;
import com.tinkerpop.blueprints.Vertex;
/**
 * 
 * @author arvin
 * KNN Search Strategy
 */
public class KNNSearch implements IGraphSearchStrategy{
	private HashSet<Vertex> knnCandidate;
    private IGraphSearchVisitor Ivisitor;
    private ArrayList<Edge> EdgeList;
    private CacheManager blcokCache;
    private RandomProb RProb;
    private boolean foundTargetOrNot = false;
    private int Stepsthreshold = 0;
    private int K;
    private boolean skipOrNot;
    private Vertex returnVertex;
    private BoundaryProccessor boundaryProccessor;
    private SimpleDateFormat simpleDateFormat;
    public KNNSearch(int Stepsthreshold, int k, double boundaryThreshold){
    	knnCandidate = new HashSet<Vertex>();
    	this.Stepsthreshold = Stepsthreshold;
    	EdgeList = new ArrayList<Edge>();
    	RProb = new RandomProb();
    	boundaryProccessor = new BoundaryProccessor(boundaryThreshold);
    	this.K = k;
    	skipOrNot = false;
    	this.simpleDateFormat = new SimpleDateFormat("yyyyMMdd_HHmmss");
    }
    
    

	@Override
	public Walker query(Vertex vertex, Walker walker) {
		Vertex root = vertex;
		System.out.println("root node : "+root.getProperty("nodeID"));
		
		
		int stepsCounter = 0;
		int pathCounter = 0;
		while((pathCounter < this.K)){
			vertex = root;
			setAdjVertexAndEdges(vertex);
			// for root
			foundTargetOrNot = Ivisitor.visitVertex(vertex, null, walker);
			
			while(!this.foundTargetOrNot && stepsCounter < this.Stepsthreshold){
				vertex = getNextVisitVertex(vertex, walker);
				if(vertex == null){
					break;
				}
				else{
					setAdjVertexAndEdges(vertex);
					stepsCounter = stepsCounter + 1;
				}
				if(stepsCounter >= 20){
					System.out.println("Steps out of threshold");
					walker.setNewPath();
				}
			}
			pathCounter = pathCounter + 1;
			this.foundTargetOrNot = false;
			stepsCounter = 0;
		}
		Ivisitor.pathWeightUpdate(walker);
		return walker;
	}
	
	
	
    
/**
 *     calculate the probability of walking to or not walking to v's neighbors and return the neighbor which should be walked
 */
	public Vertex getNextVisitVertex(Vertex lastV, Walker walker) {
		long diff;//for valid time
		
		if(EdgeList.size() != 0){
			//EdgeList = walker.getEdgeList();
			Iterator<Edge> checkAttachedTarget;
			Iterator<Edge> edgePtr = EdgeList.iterator();
			Edge e = null;
			
			//find the most prob to walk
			HashMap<Edge, Double> weightMap = new HashMap<Edge, Double>();
			double sumOfweightingValue = 0;
			double edgeWeight;
			while (edgePtr.hasNext()){
				e = edgePtr.next();
				edgeWeight = Double.parseDouble((String) e.getProperty("weight"));
				sumOfweightingValue = sumOfweightingValue + edgeWeight;
				weightMap.put(e, edgeWeight);
				// here to decide which edge should be walked
			}
				e = RProb.calculate(sumOfweightingValue,weightMap);
				e.setProperty("walked", "1");
				Vertex vIn = e.getVertex(Direction.IN);
				Vertex vOut = e.getVertex(Direction.OUT);
				if(lastV.equals(vIn)){
					foundTargetOrNot = Ivisitor.visitVertex(vOut, e, walker);
					vOut.setProperty("walked", "1");
					// check if meet valid border
					if("1".equals((String)vOut.getProperty("valid")) && "yes".equals((String)vOut.getProperty("border"))){
						checkAttachedTarget = vOut.getEdges(Direction.OUT, "attachedTarget").iterator();
						while(checkAttachedTarget.hasNext()){
							Edge attachedTargetedge = checkAttachedTarget.next();
							Vertex attachedTarget = attachedTargetedge.getVertex(Direction.OUT);
							//add shortcut target into knnCandidate
							knnCandidate.add(attachedTarget);
							//visit attached target (add to this path)
							foundTargetOrNot = Ivisitor.visitVertex(attachedTarget, attachedTargetedge, walker);
							//check the border is valid or not for now
							try {
								Date validTime = this.simpleDateFormat.parse((String)vOut.getProperty("validTime"));
								Date currentTime = Calendar.getInstance().getTime();
								// diff can be adjusted depends on datasets;
								diff = (currentTime.getTime() - validTime.getTime()) / (60 * 1000);
								if(diff > 10){
									vOut.setProperty("valid", "0");
									attachedTargetedge.remove();
								}
								else{
									//keep going
								}
								
							} catch (ParseException e1) {
								// TODO Auto-generated catch block
								e1.printStackTrace();
							}
							
							
						}
					}
					returnVertex = vOut;
					//check if meet the boundary, meet, then put all attached target into knnCandidate
					// and set foundTargetOrNot to true
					/*
					if("1".equals((String)vOut.getProperty("LandMark"))){
						foundTargetOrNot = true;
						skipOrNot = true;
						checkAttachedTarget = vOut.getEdges(Direction.OUT, "attachedTarget").iterator();
						while(checkAttachedTarget.hasNext()){
							Edge attachedTargetedge = checkAttachedTarget.next();
							//add shortcut target into knnCandidate
							knnCandidate.add(attachedTargetedge.getVertex(Direction.OUT));
							//target path update and count 
							boundaryProccessor.updateWeightbetweenTargetandBoundary(vOut,attachedTargetedge.getVertex(Direction.OUT));
							//then update boundary again
							boundaryProccessor.setTarget(attachedTargetedge.getVertex(Direction.OUT));
							boundaryProccessor.setupBoundary(attachedTargetedge.getVertex(Direction.OUT), 1);
							
						}
						//walker update and count 
						Ivisitor.pathWeightUpdate(walker);
					}
					*/
				}
				else if(lastV.equals(vOut)){
					foundTargetOrNot = Ivisitor.visitVertex(vIn, e, walker);
					vIn.setProperty("walked", "1");
					if("1".equals((String)vIn.getProperty("valid")) && "yes".equals((String)vIn.getProperty("border"))){
						checkAttachedTarget = vIn.getEdges(Direction.OUT, "attachedTarget").iterator();
						while(checkAttachedTarget.hasNext()){
							Edge attachedTargetedge = checkAttachedTarget.next();
							Vertex attachedTarget = attachedTargetedge.getVertex(Direction.OUT);
							//add shortcut target into knnCandidate
							knnCandidate.add(attachedTarget);
							//visit attached target (add to this path)
							foundTargetOrNot = Ivisitor.visitVertex(attachedTarget, attachedTargetedge, walker);
							//check the border is valid or not for now
							try {
								Date validTime = this.simpleDateFormat.parse((String)vOut.getProperty("validTime"));
								Date currentTime = Calendar.getInstance().getTime();
								// diff can be adjusted depends on datasets;
								diff = (currentTime.getTime() - validTime.getTime()) / (60 * 1000);
								if(diff > 10){
									vIn.setProperty("valid", "0");
									attachedTargetedge.remove();
								}
								else{
									//keep going
								}
								
							} catch (ParseException e1) {
								// TODO Auto-generated catch block
								e1.printStackTrace();
							}
							
							
						}
					}
					returnVertex = vIn;
					
					//check if meet the boundary. If meet, then put all attached target into knnCandidate
					// and set foundTargetOrNot to true
					/*
					if("1".equals((String)vIn.getProperty("LandMark"))){
						foundTargetOrNot = true;
						skipOrNot = true;
						checkAttachedTarget = vIn.getEdges(Direction.OUT, "attachedTarget").iterator();
						while(checkAttachedTarget.hasNext()){
							Edge attachedTargetedge = checkAttachedTarget.next();
							//add shortcut target into knnCandidate
							knnCandidate.add(attachedTargetedge.getVertex(Direction.OUT));
							//target path update and count 
							boundaryProccessor.updateWeightbetweenTargetandBoundary(vIn,attachedTargetedge.getVertex(Direction.OUT));
							//then update boundary again
							boundaryProccessor.setTarget(attachedTargetedge.getVertex(Direction.OUT));
							boundaryProccessor.setupBoundary(attachedTargetedge.getVertex(Direction.OUT), 1);
							
						}
						//walker update and count 
						Ivisitor.pathWeightUpdate(walker);
					}
					*/
				}
				
				//check if visitor found the target or not, then keep finding(go back to find)
				//skipOrNot to control the found Target is found by skip or not
				if(foundTargetOrNot){ 
					
					knnCandidate.add(walker.getLeastNode(foundTargetOrNot));
					// && !skipOrNot
					//boundaryProccessor.setTarget(walker.getLeastNode(foundTargetOrNot));
					//boundaryProccessor.setupBoundary(walker.getLeastNode(foundTargetOrNot), 1);
			
					
					
					return walker.getRoot(foundTargetOrNot);
				}
				else if(!foundTargetOrNot && !skipOrNot){
				//keep finding
					return returnVertex;
				}
		}
			else if(EdgeList.size() == 0){
				//change graph!
				String subgraphID = lastV.getProperty("subgraphID");
				String nodeID = lastV.getProperty("nodeID");
				String graphPartNeedLoad = null;
				if ("-1".equals(subgraphID)){
					// not border, can't connect to other graph
				}
				else{
					// check the borderMap table in mysql... find out which subgraph is connected by it.
					DatabaseOpts databaseOpts = new DatabaseOpts("localhost:3306","graphPartition","root","155013");
					graphPartNeedLoad = databaseOpts.checkBorderMap(nodeID,subgraphID);
					if("-1".equals(graphPartNeedLoad)){
						returnVertex = null;
					}
					else{
						if(!this.blcokCache.inCacheOrNot(graphPartNeedLoad)){
							this.blcokCache.loadGraphToCache(graphPartNeedLoad);
						}
						//set border property for walker
						lastV.setProperty("border", "yes");
						
						returnVertex = this.blcokCache.findVertexInOtherGraph(nodeID,graphPartNeedLoad);
					}
					
				}
				
				return returnVertex;
				
			}
	
		
		return null;
	}

	
	
	
	public int getStepsThreshold(){
		return this.Stepsthreshold;
	}
	public void accept(IGraphSearchVisitor vis) {
		this.Ivisitor = vis;
		
	}
	@Override
	public void setCache(CacheManager blockCache){		
		this.blcokCache = blockCache;
	}

	@Override
	public boolean successOrNot() {
		// TODO Auto-generated method stub
		if(knnCandidate.size() == this.K){
			return true;
		}
		else{
			return false;
		}
	}
	private void setAdjVertexAndEdges(Vertex lastV){
		//first clean all elements in previous list
		EdgeList.clear();
		// collect all adjacent edges
		Iterator<Edge> edgeItr = lastV.getEdges(Direction.BOTH, "edge_label").iterator();
		Edge adjEdge;
		while(edgeItr.hasNext()){
			adjEdge = edgeItr.next();
			if("0".equals(adjEdge.getProperty("walked"))){
				EdgeList.add(adjEdge);
			}
		}
		
	}




}
