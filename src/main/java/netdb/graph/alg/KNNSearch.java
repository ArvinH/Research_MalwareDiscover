package netdb.graph.alg;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.TreeSet;

import netdb.graph.opts.framework.Target;
import netdb.graph.opts.framework.Walker;
import netdb.graph.unit.EdgesCollection;
import netdb.graph.unit.VerticesCollection;

import com.tinkerpop.blueprints.Direction;
import com.tinkerpop.blueprints.Edge;
import com.tinkerpop.blueprints.Vertex;

public class KNNSearch implements IGraphSearchStrategy{
	private TreeSet<Target> knnCandidate;
    private IGraphSearchVisitor Ivisitor;
    private ArrayList<Vertex> adjacentVertices;
    private ArrayList<Edge> EdgeList;
    private boolean hasNextNode = false;
    private int threshold = 0;
    public KNNSearch(int threshold){
    	knnCandidate = new TreeSet<Target>();
    	this.threshold = threshold;
    	adjacentVertices = new ArrayList<Vertex>();
    	EdgeList = new ArrayList<Edge>();
    }
    
	public List<Vertex> getNextVisitVertex(Vertex lastV, Walker walker) {
		// calculate the probability of walking to or not walking to v's neighbors
		// pick one v from lastV

		// collect all adjacent vertices
		adjacentVertices.addAll(VerticesCollection.convert(lastV.getVertices(Direction.OUT, "edge labels")));
		adjacentVertices.addAll(VerticesCollection.convert(lastV.getVertices(Direction.IN, "edge labels")));

		EdgeList.addAll(EdgesCollection.convert(lastV.getEdges(Direction.OUT, "edge labels")));
		EdgeList.addAll(EdgesCollection.convert(lastV.getEdges(Direction.IN, "edge labels")));
		
		Iterator<Edge> edgePtr = EdgeList.iterator();
		
		while (edgePtr.hasNext()){
			Edge e = edgePtr.next();
			Double weight = e.getProperty("weight");
			Vertex v = e.getVertex(Direction.IN);
			Ivisitor.visitVertex(v, null, walker);
			hasNextNode = true;
		
			if (!hasNextNode){  
				// no next node
				// return null?	
			}
		}
		return null;
	}
	public int getThreshold(){
		return this.threshold;
	}
	public void accept(IGraphSearchVisitor vis) {
		Ivisitor = vis;
		
	}


}
