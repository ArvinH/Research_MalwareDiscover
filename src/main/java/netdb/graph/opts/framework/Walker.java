package netdb.graph.opts.framework;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.TreeMap;

import com.tinkerpop.blueprints.Edge;
import com.tinkerpop.blueprints.Vertex;
/**
 * 
 * @author arvin
 * Walker : record all nodes and edges it walks by.
 */
public class Walker {
  private ArrayList<Vertex> visitedNodes;
  private TreeMap<Integer, ArrayList<Vertex>> foundPathvertex;
  private TreeMap<Integer, ArrayList<Edge>> foundPathedge;
  private ArrayList<Edge> visitedEdges;
  private int nth_path_node;
  private int nth_path_edge;
  
  public Walker() {
	  this.visitedNodes = new ArrayList<Vertex>();
	  this.visitedEdges = new ArrayList<Edge>();
	  this.foundPathvertex = new TreeMap<Integer, ArrayList<Vertex>>();
	  this.foundPathedge = new TreeMap<Integer, ArrayList<Edge>>();
	  this.nth_path_node = 0;
	  this.nth_path_edge = 0;
  }
  
  public void addNode(Vertex v, boolean foundTargetOrNot) {
	  if(foundTargetOrNot){
		  //record new path
		  this.visitedNodes.add(v);
		  this.foundPathvertex.put(this.nth_path_node, this.visitedNodes);
		  this.nth_path_node = this.nth_path_node + 1;
		  this.visitedNodes = new ArrayList<Vertex>();
	  }
	  else if(!foundTargetOrNot){
		  this.visitedNodes.add(v);
		  this.foundPathvertex.put(this.nth_path_node, this.visitedNodes);
	  }
  }
  
  public void addEdge(Edge e, boolean foundTargetOrNot) {
	  if(foundTargetOrNot){
		  //record new path
		  this.nth_path_edge = this.nth_path_edge + 1;
		  this.visitedEdges = new ArrayList<Edge>();
		  this.visitedEdges.add(e);
		  this.foundPathedge.put(this.nth_path_edge, this.visitedEdges);
	  }
	  else if(!foundTargetOrNot){
		  this.visitedEdges.add(e);
		  this.foundPathedge.put(this.nth_path_edge, this.visitedEdges);
	  }
	  
  }
  
  public Vertex getLeastNode(boolean foundTargetOrNot) {
	  if(foundTargetOrNot){
		  return this.foundPathvertex.get(this.nth_path_node-1).get(this.foundPathvertex.get(this.nth_path_node-1).size()-1);
	  }
	  return this.visitedNodes.get(this.visitedNodes.size()-1);
  }
  
  public Vertex getRoot(){
	  return this.visitedNodes.get(0);
  }
  
  public ArrayList<Vertex> getFoundTargets(){
	  ArrayList<Vertex> targetList = new ArrayList<Vertex>();
	  Vertex targetCandidate = null;
	  for(int i : this.foundPathvertex.keySet()){
		  targetCandidate = this.foundPathvertex.get(i).get(this.foundPathvertex.get(i).size()-1);
		  if("1".equals(targetCandidate.getProperty("type"))){
			  targetList.add(targetCandidate);
		  }
	  }
	  return targetList;
  }
  
  public TreeMap<Integer, ArrayList<Vertex>> getAllPath(){
	  //return ALL Path
	  return this.foundPathvertex;
  }
  
  public ArrayList<Edge> getLastPath(){
	  //return last Path(all edge in the path)
	 return this.foundPathedge.get(this.foundPathedge.lastKey());
  }
  public ArrayList<Edge> getPath(int i){
	  //return ith Path(all edge in the path)
	 return this.foundPathedge.get(i);
  }

  public double getPathWeight() {
	  //not finished yet
	  double weight = 0;
	  Iterator<Edge> eptr = this.visitedEdges.iterator();
	  while(eptr.hasNext()){
		  weight += (double)eptr.next().getProperty("weight");
	  }
	  return weight;
  }
}
