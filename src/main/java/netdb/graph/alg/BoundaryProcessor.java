package netdb.graph.alg;

import java.util.HashMap;
import java.util.Iterator;

import netdb.graph.opts.framework.TargetNode;

import com.tinkerpop.blueprints.Direction;
import com.tinkerpop.blueprints.Edge;
import com.tinkerpop.blueprints.Vertex;

public class BoundaryProcessor {
	private final double threshold;
	private Vertex target;
	private HashMap<Vertex, TargetNode<Vertex>> targetBoundaryTree;
	public BoundaryProcessor(double threshold){
		this.threshold = threshold;
	}
	public void setTarget(Vertex target){
		this.target = target;
		//will be new every time I setTarget, so may be need to be modify to save memory
		//but don't consider that now...
		this.targetBoundaryTree = new HashMap<Vertex, TargetNode<Vertex>>();
	}
	
	public void setupBoundary(Vertex target, double probNow){
		// start to record target boundary tree
		TargetNode<Vertex> targetRoot = new TargetNode<Vertex>(target);
		this.targetBoundaryTree.put(target, targetRoot);
		
		Iterator<Edge> firstlevelEdge = target.getEdges(Direction.BOTH, "edge labels").iterator();
		Edge edge;
		Vertex vertex;
		Edge e;
		RandomProb RProb = new RandomProb();	
		while(firstlevelEdge.hasNext()){
			edge = firstlevelEdge.next();	
			if(edge.getVertex(Direction.IN) != null && !edge.getVertex(Direction.IN).equals(target)){
				vertex = edge.getVertex(Direction.IN);
				Iterator<Edge> secondlevelEdge = vertex.getEdges(Direction.BOTH, "edge labels").iterator();
				//find the prob of every edge
				HashMap<Edge, Double> weightMap = new HashMap<Edge, Double>();
				while (secondlevelEdge.hasNext()){
					e = secondlevelEdge.next();
					weightMap.put(e, (Double)e.getProperty("weight"));
					// here to decide which edge should be walked
				}
				probNow = probNow *= RProb.probToTarget(weightMap,edge);
				if( probNow < threshold){
					vertex.setProperty("LandMark",true);
					vertex.addEdge("attachedTarget", target);
					return;
				}
				else{
					TargetNode<Vertex> child = new TargetNode<Vertex>(vertex);
					targetRoot.insertChild(child);
					updateBoundary(vertex, edge, probNow, child);
				}
			}
			if(edge.getVertex(Direction.OUT) != null && !edge.getVertex(Direction.OUT).equals(target)){
				vertex = edge.getVertex(Direction.OUT);
				Iterator<Edge> secondlevelEdge = vertex.getEdges(Direction.BOTH, "edge labels").iterator();
				//find the prob of every edge
				HashMap<Edge, Double> weightMap = new HashMap<Edge, Double>();
				while (secondlevelEdge.hasNext()){
					e = secondlevelEdge.next();
					weightMap.put(e, (Double)e.getProperty("weight"));
					// here to decide which edge should be walked
				}
				probNow = probNow *= RProb.probToTarget(weightMap,edge);
				if( probNow < threshold){
					vertex.setProperty("LandMark",true);
					vertex.addEdge("attachedTarget", target);
					return;
				}
				else{
					TargetNode<Vertex> child = new TargetNode<Vertex>(vertex);
					targetRoot.insertChild(child);
					updateBoundary(vertex, edge, probNow, child);
				}
			}
		}
	}
	
	public void updateBoundary(Vertex oriV,Edge oriE, double probNow, TargetNode<Vertex> node){
		Iterator<Edge> levelEdge = oriV.getEdges(Direction.BOTH, "edge labels").iterator();
		Edge edge;
		Edge e;
		Vertex vertex;
		RandomProb RProb = new RandomProb();
		while(levelEdge.hasNext()){
			edge = levelEdge.next();	
			if((oriE != null) && edge.equals(oriE)){ //skip oriE
				edge = levelEdge.next();
			}
			if(edge.getVertex(Direction.IN) != null && !edge.getVertex(Direction.IN).equals(oriV)){
				vertex = edge.getVertex(Direction.IN);
				Iterator<Edge> secondlevelEdge = vertex.getEdges(Direction.BOTH, "edge labels").iterator();
				//find the prob of every edge
				HashMap<Edge, Double> weightMap = new HashMap<Edge, Double>();
				while (secondlevelEdge.hasNext()){
					e = secondlevelEdge.next();
					weightMap.put(e, (Double)e.getProperty("weight"));
					// here to decide which edge should be walked
				}
				probNow = probNow *= RProb.probToTarget(weightMap,edge);
				if( probNow < threshold){
					oriV.setProperty("LandMark",true);
					oriV.addEdge("attachedTarget", target);
					return;
				}
				else{
					TargetNode<Vertex> child = new TargetNode<Vertex>(vertex);
					node.insertChild(child);
					updateBoundary(vertex, edge, probNow, child);
				}
				
			}
			if(edge.getVertex(Direction.OUT) != null && !edge.getVertex(Direction.OUT).equals(oriV)){
				vertex = edge.getVertex(Direction.IN);
				Iterator<Edge> secondlevelEdge = vertex.getEdges(Direction.BOTH, "edge labels").iterator();
				//find the prob of every edge
				HashMap<Edge, Double> weightMap = new HashMap<Edge, Double>();
				while (secondlevelEdge.hasNext()){
					e = secondlevelEdge.next();
					weightMap.put(e, (Double)e.getProperty("weight"));
					// here to decide which edge should be walked
				}
				probNow = probNow *= RProb.probToTarget(weightMap,edge);
				if( probNow < threshold){
					oriV.setProperty("LandMark",true);
					oriV.addEdge("attachedTarget", target);
					return;
				}
				else{
					TargetNode<Vertex> child = new TargetNode<Vertex>(vertex);
					node.insertChild(child);
					updateBoundary(vertex, edge, probNow, child);
				}
			}
		}
		return; // back to last level
	}

}
