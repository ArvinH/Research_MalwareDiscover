package netdb.graph.alg;

import java.util.HashMap;
import java.util.Iterator;

import netdb.graph.opts.framework.OptsExperimentSet;

import com.tinkerpop.blueprints.Direction;
import com.tinkerpop.blueprints.Edge;
import com.tinkerpop.blueprints.Vertex;

public class BoundaryProcessor {
	private final double threshold;
	private Vertex target;
	public BoundaryProcessor(double threshold){
		this.threshold = threshold;
	}
	public void setTarget(Vertex target){
		this.target = target;
	}
	
	public void setupBoundary(Vertex target, double probNow){
		Iterator<Edge> firstlevelEdge = target.getEdges(Direction.BOTH, "edge labels").iterator();
		Edge edge;
		Vertex vertex;
		Edge e;
		RandomProb RProb = new RandomProb();	
		while(firstlevelEdge.hasNext()){
			edge = firstlevelEdge.next();	
			if(edge.getVertex(Direction.IN) != null && !edge.getVertex(Direction.IN).equals(target)){
				vertex = edge.getVertex(Direction.IN);
				Iterator<Edge> secondlevelEdge = vertex.getEdges(Direction.BOTH, "edge labels").iterator();
				//find the prob of every edge
				HashMap<Edge, Double> weightMap = new HashMap<Edge, Double>();
				while (secondlevelEdge.hasNext()){
					e = secondlevelEdge.next();
					weightMap.put(e, (Double)e.getProperty("weight"));
					// here to decide which edge should be walked
				}
				probNow = probNow *= RProb.probToTarget(weightMap,edge);
				if( probNow < threshold){
					vertex.setProperty("LandMark",true);
					vertex.addEdge("attachedTarget", target);
					return;
				}
				else{
					
					updateBoundary(vertex, edge, probNow);
				}
			}
			if(edge.getVertex(Direction.OUT) != null && !edge.getVertex(Direction.OUT).equals(target)){
				vertex = edge.getVertex(Direction.OUT);
				Iterator<Edge> secondlevelEdge = vertex.getEdges(Direction.BOTH, "edge labels").iterator();
				//find the prob of every edge
				HashMap<Edge, Double> weightMap = new HashMap<Edge, Double>();
				while (secondlevelEdge.hasNext()){
					e = secondlevelEdge.next();
					weightMap.put(e, (Double)e.getProperty("weight"));
					// here to decide which edge should be walked
				}
				probNow = probNow *= RProb.probToTarget(weightMap,edge);
				if( probNow < threshold){
					vertex.setProperty("LandMark",true);
					vertex.addEdge("attachedTarget", target);
					return;
				}
				else{
					
					updateBoundary(vertex, edge, probNow);
				}
			}
		}
	}
	
	public void updateBoundary(Vertex oriV,Edge oriE, double probNow){
		Iterator<Edge> levelEdge = oriV.getEdges(Direction.BOTH, "edge labels").iterator();
		Edge edge;
		Edge e;
		Vertex vertex;
		RandomProb RProb = new RandomProb();
		while(levelEdge.hasNext()){
			edge = levelEdge.next();	
			if((oriE != null) && edge.equals(oriE)){ //skip oriE
				edge = levelEdge.next();
			}
			if(edge.getVertex(Direction.IN) != null && !edge.getVertex(Direction.IN).equals(oriV)){
				vertex = edge.getVertex(Direction.IN);
				Iterator<Edge> secondlevelEdge = vertex.getEdges(Direction.BOTH, "edge labels").iterator();
				//find the prob of every edge
				HashMap<Edge, Double> weightMap = new HashMap<Edge, Double>();
				while (secondlevelEdge.hasNext()){
					e = secondlevelEdge.next();
					weightMap.put(e, (Double)e.getProperty("weight"));
					// here to decide which edge should be walked
				}
				probNow = probNow *= RProb.probToTarget(weightMap,edge);
				if( probNow < threshold){
					oriV.setProperty("LandMark",true);
					oriV.addEdge("attachedTarget", target);
					return;
				}
				else{
					
					updateBoundary(vertex, edge, probNow);
				}
				
			}
			if(edge.getVertex(Direction.OUT) != null && !edge.getVertex(Direction.OUT).equals(oriV)){
				vertex = edge.getVertex(Direction.IN);
				Iterator<Edge> secondlevelEdge = vertex.getEdges(Direction.BOTH, "edge labels").iterator();
				//find the prob of every edge
				HashMap<Edge, Double> weightMap = new HashMap<Edge, Double>();
				while (secondlevelEdge.hasNext()){
					e = secondlevelEdge.next();
					weightMap.put(e, (Double)e.getProperty("weight"));
					// here to decide which edge should be walked
				}
				probNow = probNow *= RProb.probToTarget(weightMap,edge);
				if( probNow < threshold){
					oriV.setProperty("LandMark",true);
					oriV.addEdge("attachedTarget", target);
					return;
				}
				else{
					updateBoundary(vertex, edge, probNow);
				}
			}
		}
		return; // back to last level
	}

}
