package netdb.graph.alg;

import java.util.Date;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Iterator;

import netdb.graph.opts.framework.OptsExperimentSet;
import netdb.graph.opts.framework.Walker;

import com.tinkerpop.blueprints.Edge;
import com.tinkerpop.blueprints.Vertex;

/**
 * 
 * @author arvin first: this visitor is used to insert all visited Vertex and
 *         edges into walker, and also used to update the weight on the whole
 *         path that walker pass by.
 * 
 *         Second: check the vertex it visited is target or not
 */
public class AccumulateVisitor implements IGraphSearchVisitor {
	private boolean targetOrNot;
	private String TargetType;
	private WeightingFunction weightingFunction;
	private long slidingWindowSize;
	private SimpleDateFormat simpleDateFormat;

	/**
	 * 
	 * @param targetList
	 *            : List of target
	 * @param threshold
	 *            : threshold for BoundaryProcessor
	 * @param slidingWindowSize
	 *            : sliding window gap(minutes)
	 */
	public AccumulateVisitor(String TargetType, long slidingWindowSize) {
		this.TargetType = TargetType;
		this.targetOrNot = false;
		this.slidingWindowSize = slidingWindowSize;
		this.weightingFunction = new WeightingFunction(this.slidingWindowSize);
		this.simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
	}

	/**
	 * visit vertex and Accumulate
	 */
	public boolean visitVertex(Vertex v, Edge impactedEdge, Walker walker) {
		/**
		 * check the v is the target or not
		 */
		int count = 0;
		ArrayList<String> counting;
		String timeStamp = null;
		this.targetOrNot = targetCompare(v, this.TargetType,
				walker.getQueryTime(), walker);
		// if v is not root
		if (impactedEdge != null) {
			walker.addNode(v, this.targetOrNot);

			if (String.class.isAssignableFrom(impactedEdge.getProperty("count")
					.getClass())) {
				count = 1;
				timeStamp = walker.getQueryTime();
				ArrayList<String> newcounting = new ArrayList<String>();
				newcounting.add(timeStamp);
				newcounting.add(String.valueOf(count));
				impactedEdge.setProperty("count", newcounting);
				walker.addEdge(impactedEdge, v, this.targetOrNot);
			} else {
				counting = impactedEdge.getProperty("count");
				count = Integer.parseInt(counting.get(counting.size() - 1));
				timeStamp = walker.getQueryTime();
				counting.add(timeStamp);
				counting.add(String.valueOf(count + 1));
				impactedEdge.setProperty("count", counting);
				walker.addEdge(impactedEdge, v, this.targetOrNot);

			}

		}// if v is root
		else if (impactedEdge == null) {
			walker.addNode(v, this.targetOrNot);
		}

		return this.targetOrNot;
	}

	public void pathWeightUpdate(Walker walker) {
		this.weightingFunction.update(walker);
	}

	public void setTargetOrNotFlag(boolean flag) {
		this.targetOrNot = flag;
	}

	public String checkBorderTarget(Vertex v) {
		String borderTargetID = v.getProperty("target_border");
		if (borderTargetID != null) {
			return borderTargetID;
		}
		return null;
	}

	public boolean targetCompare(Vertex v, String TargetType, String timeStamp,
			Walker walker) {
		boolean compareResult = false;
		ArrayList<String> counting;
		int targetCount;
		boolean containTargetOrNot = walker.containTargetOrNot(v);
		if (TargetType.equals(v.getProperty("type")) && !containTargetOrNot) {
			compareResult = true;
			// add target count by time
			if (String.class
					.isAssignableFrom(v.getProperty("count").getClass())) {
				targetCount = 1;
				ArrayList<String> newcounting = new ArrayList<String>();
				newcounting.add(timeStamp);
				newcounting.add(String.valueOf(targetCount));
				v.setProperty("count", newcounting);

			} else {
				counting = v.getProperty("count");
				targetCount = Integer
						.parseInt(counting.get(counting.size() - 1));
				counting.add(timeStamp);
				counting.add(String.valueOf(targetCount + 1));
				v.setProperty("count", counting);

			}
		}

		return compareResult;
	}

}
